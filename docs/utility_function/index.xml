<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Utility Function on EMOC</title><link>https://sunxlei.github.io/EMOCDoc/docs/utility_function/</link><description>Recent content in Utility Function on EMOC</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://sunxlei.github.io/EMOCDoc/docs/utility_function/index.xml" rel="self" type="application/rss+xml"/><item><title>Non-dominated Sorting</title><link>https://sunxlei.github.io/EMOCDoc/docs/utility_function/ndsort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/utility_function/ndsort/</guid><description>Non-dominated Sorting # File position: /EMOC/src/core/nd_sort.h and /EMOC/src/core/nd_sort.cpp
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } void NonDominatedSort(Individual **pop, int pop_num, int obj_num, bool is_consider_cons = false) Do the non-dominated sorting on current population pop. The results are stored in the rank_ variable of each individual in the population.
Parameter: pop: Individual**, default=None&amp;nbsp &amp;nbsp The population which need to be initialized. It's an array of Individual* where each Individual* is a pointer to a individual in the population.</description></item><item><title>Uniform Weight Vector Generation</title><link>https://sunxlei.github.io/EMOCDoc/docs/utility_function/uniform_weight_vector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/utility_function/uniform_weight_vector/</guid><description>Uniform Weight Vector Generation # File position: /EMOC/src/core/uniform_point.h and /EMOC/src/core/uniform_point.cpp
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } double** UniformPoint(int num, int* weight_num, int obj_num) Generate uniform weight vectors.
Parameter: num: int, default=None&amp;nbsp &amp;nbsp Number of uniform weight vectors want to generate. weight_num: int*, default=None&amp;nbsp &amp;nbsp The real number of generated weight vectors. obj_num: int, default=None&amp;nbsp &amp;nbsp The dimension of generated weight vectors. Returns: lambda: double**&amp;nbsp &amp;nbsp Generated uniform weight vectors.</description></item><item><title>Aggregation Functions</title><link>https://sunxlei.github.io/EMOCDoc/docs/utility_function/aggregation_functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/utility_function/aggregation_functions/</guid><description>Aggregation Functions # File position: /EMOC/src/core/utility.h and /EMOC/src/core/utility.cpp
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } There are several aggregation functions for decomposition:
double CalWeightedSum(Individual *ind, double *weight_vector, double *ideal_point, int obj_num)
double CalInverseChebycheff(Individual *ind, double *weight_vector, double *ideal_point, int obj_num)
double CalPBI(Individual *ind, double *weight_vector, double *ideal_point, int obj_num, double theta)
double CalWeightedSum(Individual *ind, double *weight_vector, double *ideal_point, int obj_num) Use weighted sum method to decompose the individual ind based on weight vector weight_vector.</description></item><item><title>Sampling Functions</title><link>https://sunxlei.github.io/EMOCDoc/docs/utility_function/sampling_functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/utility_function/sampling_functions/</guid><description>Sampling Functions # .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } Random Number Generation # File position: /EMOC/vendor/random.h and /EMOC/vendor/random.cpp
Random number generation is a basic function for evolutionary algorithm, EMOC provides several random number related functions as below:
double randomperc() int rnd(int low, int high) double rndreal(double low, double high) double randomperc() Fetch a single random number between 0.0 and 1.0.
Parameter: void Returns: rand: double&amp;nbsp &amp;nbsp A random number between 0.</description></item><item><title>Math Related Functions</title><link>https://sunxlei.github.io/EMOCDoc/docs/utility_function/math_related_functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/utility_function/math_related_functions/</guid><description>Math Related Functions # File position: /EMOC/src/core/utility.h and /EMOC/src/core/utility.cpp
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } In EMOC, some mathematic operations are also provided for convenience:
int Combination(int n, int k)
double CalculateCos(double *a, double *b, int dimension)
double CalculateSin(double *a, double *b, int dimension)
double CalculateNorm(double *vector, int dimension)
double CalculateDotProduct(double *vector1, double *vector2, int dimension)</description></item><item><title>Miscellaneous</title><link>https://sunxlei.github.io/EMOCDoc/docs/utility_function/miscellaneous/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/utility_function/miscellaneous/</guid><description>Ideal Point and Nadir Point Update # .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } File position: /EMOC/src/core/utility.h and /EMOC/src/core/utility.cpp
void UpdateIdealpoint(Individual *ind, double *ideal_point, int obj_num) void UpdateNadirpoint(Individual *ind, double *nadir_point, int obj_num) void UpdateIdealpoint(Individual *ind, double *ideal_point, int obj_num) Update the ideal point ideal_point with given individual ind.
Parameter: ind: Individual*, default=None&amp;nbsp &amp;nbsp The pointer to the given individual. ideal_point: double*, default=None&amp;nbsp &amp;nbsp The pointer to the ideal point which will be updated.</description></item></channel></rss>