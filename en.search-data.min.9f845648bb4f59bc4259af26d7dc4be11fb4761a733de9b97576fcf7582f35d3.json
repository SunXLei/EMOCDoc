[{"id":0,"href":"/EMOCDoc/docs/core_class/overview/","title":"Architecture of EMOC","section":"Core Class","content":"Architecture of EMOC #  Before we dive into the details and functions of some core classes, let\u0026rsquo;s take a look at the architecture of EMOC.\nFile Structure #  After going into the source code directory \u0026rsquo;/EMOC/src\u0026rsquo;, users can see a lot of .h and .cpp files organized in a structure shown below.\nThere are one \u0026lsquo;main.cpp\u0026rsquo; file and six folders in the \u0026rsquo;/src\u0026rsquo; directory of EMOC. It is very easy to find the implementation details of specified algorithms, problems, operators and metrics in each folders. The \u0026lsquo;main.cpp\u0026rsquo; file is the entry point of EMOC. The first folder \u0026rsquo;/core\u0026rsquo; contains some basic classes and important functions. The second folder \u0026rsquo;/problem\u0026rsquo; has a lot of subfolder for different test problems. For example, the subfolder \u0026rsquo;/uf\u0026rsquo; contains 10 UF problems (i.e., UF1~10). The next folder \u0026rsquo;/algorithm\u0026rsquo; is used to store all the algorithms in EMOC, where each algorithm has an independent subfolder. All the relevant functions are member functions of the specified algorithm class. The \u0026rsquo;/operator\u0026rsquo; and \u0026rsquo;/metric\u0026rsquo; folder store the functions of all the operators and performance indicators, respectively. The last folder \u0026rsquo;/ui\u0026rsquo; stores the classes of interactive GUI of EMOC.\nClass Diagram #  EMOC also has a simple architecture where it involves some core classes structured as below.\nThe leftmost class EMOCManager is the manager class of EMOC which controls the command mode and GUI mode. It contains some basic state variables of EMOC such as pause or not in GUI mode. EMOCManager class also has an array of Global class. A Global object is an execution entity of EMOC which basically is a specified algorithm optimized a certain problem with pre-defined parameters. All the relevant datas are stored in it. The following class is Individual that represents a solution of population. The last two classes Algorithm and Problem are parent classes of all the algorithms and problems respectively. They provide some useful interfaces and declared a few virtual functions that need to implemented by their subclasses.\nAll the details of these core classes will be introduced in the following sections.\n"},{"id":1,"href":"/EMOCDoc/docs/indicator/gd/","title":"Generational Distance","section":"Indicator","content":"Generational Distance #  File position: /EMOC/src/metric/gd.h and /EMOC/src/metric/gd.cpp\n .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }   double CalculateGD(Individual** pop, int pop_num, int obj_num, double** pf_data, int pf_size)   Calculate the generational distance value of current population pop based on the pareto front data pf_data.\n Parameter:  pop: Individual**, default=None\u0026nbsp \u0026nbsp The population which need to be initialized. It's an array of Individual* where each Individual* is a pointer to a individual in the population. pop_num: int, default=None\u0026nbsp \u0026nbsp The size of the given population. obj_num: int, default=None\u0026nbsp \u0026nbsp The number of objectives. pf_data: double**, default=None\u0026nbsp \u0026nbsp The pareto front data. It's a 2D array of double (pf_size X obj_num). pf_size: int, default=None\u0026nbsp \u0026nbsp The size of the pareto front pf_data.   Returns:  gd_value: double\u0026nbsp \u0026nbsp Generational distance of current population pop.     "},{"id":2,"href":"/EMOCDoc/docs/quickstart/user_interface_mode/","title":"Graphic User Interface Mode","section":"Quick Start","content":"Graphic User Interface Mode #  EMOC is implemented with a user-friendly graphic user interface (GUI) which can help users get started quickly. We recommend using EMOC in GUI mode for general cases.\nRun EMOC with GUI #  When EMOC has been built successfully, go to the directory of executable file and open the terminal. Enable the user interface mode with the following command:\n./EMOC -g For windows, change the \u0026rsquo;./EMOC\u0026rsquo; to \u0026lsquo;EMOC.exe\u0026rsquo;.\n(Note: If you want to calculate the indicator values of optimization results, the executable file should in the same directory with \u0026rsquo;/pf_data\u0026rsquo;.)\nTest Module #  After running EMOC in GUI mode, the default test module will be launched. This module is used to execute one algorithm on one problem each time. The optimization process will be displayed by a figure and the result will be recorded in a table.\nThe interface of test module of EMOC is shown in the figure above, the functions of each regions are:\n Region A : Select the algorithm to be executed. Region B : Select the problem to be executed and config the parameters of this run. Note the \u0026lsquo;D\u0026rsquo;, \u0026lsquo;M\u0026rsquo;, \u0026lsquo;N\u0026rsquo; and \u0026lsquo;Evaluation\u0026rsquo; denoted for the decision variable dimension, objective dimension, population size and max evaluation respectively. Region C : Config the size and position of plotting figure. Region D : Run EMOC with the current configuration. Region E : Result history table for different runs. The last column of this table can be selected and changed to other information. Region F : Open another UI window for further analyzing the optimization results. Region G : Control the procedure of optimization (i.e., continue, pause and stop).  After launching the test module of EMOC, users should first config the algorithm and problem to be executed in Region A and Region B, then click the start button in Region D. A figure window will pop up to show the real time population of optimization:\nAnd users can use the buttons in Region G to control the procedure of optimization. When the current run is finished, all the historical results can be seen in the Region E.\nExperiment Module #  Users can change to the experiment module by click the \u0026lsquo;Mode\u0026rsquo; in the menu and select the \u0026lsquo;Experiment Module\u0026rsquo; in the popup.\nThe experiment module is mainly for large scale experiment with various algorithms and problems. Multi-thread is also used to accelerating the process. The interface of this module is shown below.\nThe functions of each regions are:\n Region A : Left-click the name string to select the algorithms and problems to be executed. Region B : Config the parameters of for different algorithms and problems. The parameters meanings are same in test module. Region C : Set the parameters of this experiment, such as \u0026lsquo;Thread Num\u0026rsquo; (the number of thread you want to use), \u0026lsquo;Number of Runs\u0026rsquo; (the number of runs for each problem) and \u0026lsquo;Save Interval\u0026rsquo; (population saving interval in generation). Region D : Run EMOC with the current configuration. Region E : Control the procedure of this experiment (i.e., continue, pause and stop). Region F : Show the statistical results of current experiment. Region G : Config the types of data to be displayed in the table. Region H : Save the table in the format of Excel and LaTex.  After changing to the experiment module, users should first select the algorithms and problems to be executed in Region A and set their parameters in Region B. The configuration of this experiment can be set in Region C. Then click the button in Region D to start the experiment. The up-to-date optimization results will be displayed in the table of Region F. Users can change the display information and statistical test methods in Region G. After finishing the experiment, Region H provides the saving function of table. All the optimization results and saving tables will be output to the directory \u0026rsquo;/output\u0026rsquo;.\n"},{"id":3,"href":"/EMOCDoc/docs/install/","title":"Install","section":"Docs","content":"Installing EMOC #  EMOC is now available on Windows, Linux and MacOS. There are few steps need to install EMOC as below.\nDependency #    CMake\nCMake is an open-source, cross-platform family of tools designed to build, test and package software. EMOC uses it to generate the build system files on different platforms. You can download it from here. The minimum needed version of CMake is 3.10. For more information please refer to the CMake documentation.\n  Visual Studio 2019 (for windows)\nVisual Studio (VS) is an Integrated Development Environment (IDE) for C++. EMOC generates the VS project file on Windows to compile the source code. You can download it from here .\n  Gnuplot (for windows)\nGnuplot is a portable command-line driven graphing utility. EMOC uses it to provide some visualization functions. The installation for Linux and MacOS is handled in the build script files. For windows, users need to install it from here. We recommend to use the version 5.0.1.\n  Git (optional)\nYou can use git to download the EMOC source code from github conveniently or just click the download button on the EMOC github page directly.\n  Get the Source Code #  Use git command #  If you have git installed on your system, use git clone command to get the EMOC source code as below:\ngit clone https://github.com/SunXLei/EMOC.git Download from github page #  Go to the EMOC github page and click the option \u0026lsquo;Download ZIP\u0026rsquo;:\nand unzip the file wherever you want.\nBuild #  When you have got the source code, go to the root directory of EMOC. We have prepared some script files for the ease of building EMOC.\nFor Windows #  Double-click the file \u0026lsquo;build_window.bat\u0026rsquo;, it will detect the Visual Studio installed on your system and generate the project file automatically. After executing the \u0026lsquo;.bat\u0026rsquo; file, go to the \u0026rsquo;/build\u0026rsquo; directory and open the \u0026lsquo;EMOC.sln\u0026rsquo; file with Visual Studio.\nYou can travel the code and run it in VS directly or find the executable file \u0026lsquo;EMOC.exe\u0026rsquo; in root directory after compiling it.\nFor Linux and MacOS #  Open the terminal and change the current directory to the root directory of EMOC. Build EMOC with following command:\nLinux:\nbash ./build_linux.sh MacOS:\nbash ./build_macos.sh The executable file \u0026lsquo;EMOC\u0026rsquo; will appear in the root directory when building successfully.\n"},{"id":4,"href":"/EMOCDoc/docs/utility_function/ndsort/","title":"Non-dominated Sorting","section":"Utility Function","content":"Non-dominated Sorting #  File position: /EMOC/src/core/nd_sort.h and /EMOC/src/core/nd_sort.cpp\n .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }   void NonDominatedSort(Individual **pop, int pop_num, int obj_num, bool is_consider_cons = false)   Do the non-dominated sorting on current population pop. The results are stored in the rank_ variable of each individual in the population.\n Parameter:  pop: Individual**, default=None\u0026nbsp \u0026nbsp The population which need to be initialized. It's an array of Individual* where each Individual* is a pointer to a individual in the population. pop_num: int, default=None\u0026nbsp \u0026nbsp The size of the given population. obj_num: int, default=None\u0026nbsp \u0026nbsp The number of objectives. is_consider_cons: bool, default=false\u0026nbsp \u0026nbsp Whether to consider the constraints of individual in the sorting.   Returns:  void     "},{"id":5,"href":"/EMOCDoc/docs/extend_emoc/problem/","title":"Problem","section":"Extend EMOC","content":"Add New Problems in EMOC #  Due to the simple structure of EMOC, it is straightforward to add a new problem in EMOC. This needs three steps as below. We will take the test problem ZDT1 as an example.\nCreate the Declaration #  First, we need to create a header file to make a declaration of ZDT1. Although there is no strict position request. We recommend to go to the directory \u0026rsquo;/src/problem/\u0026rsquo;, make a new directory \u0026rsquo;/zdt\u0026rsquo; and create a header file \u0026lsquo;zdt.h\u0026rsquo; in it.\nIn \u0026lsquo;zdt.h\u0026rsquo;, we declare the class ZDT1 which inherits from class Problem:\n#pragma once #include \u0026#34;core/individual.h\u0026#34;#include \u0026#34;problem/problem.h\u0026#34; namespace emoc {  \tclass ZDT1 :public Problem \t{ \tpublic: \tZDT1(int dec_num, int obj_num); \tvirtual ~ZDT1();  \tvoid CalObj(Individual* ind); \t};  } The structure of ZDT1 is very simple, just a constructor, a deconstructor and a virtual function CalObj(Individual* ind) inherit from parent class Problem. In each evaluation, EMOC will call the CalObj function to calculate the objective value.\nCreate the Definition #  After declaring the class ZDT1, the \u0026lsquo;zdt.cpp\u0026rsquo; file needs to be created in the same directory. In \u0026lsquo;zdt.cpp\u0026rsquo;, we define the three functions which declared in \u0026lsquo;zdt.h\u0026rsquo;:\n#include \u0026#34;problem/zdt/zdt.h\u0026#34; #include \u0026lt;cmath\u0026gt; #include \u0026#34;core/macro.h\u0026#34;#include \u0026#34;core/global.h\u0026#34; namespace emoc {  \tZDT1::ZDT1(int dec_num, int obj_num) :Problem(dec_num, obj_num) \t{ \tfor (int i = 0; i \u0026lt; dec_num; ++i) \t{ \tlower_bound_[i] = 0.0; \tupper_bound_[i] = 1.0; \t} \t}  \tZDT1::~ZDT1() \t{  \t}  \tvoid ZDT1::CalObj(Individual* ind) \t{ \tdouble f1 = 0, f2 = 0; \tdouble g = 0, h = 0;  \tf1 = ind-\u0026gt;dec_[0]; \tfor (int i = 1; i \u0026lt; dec_num_; i++) \t{ \tg += ind-\u0026gt;dec_[i]; \t}  \tg = 1 + g * 9.0 / (dec_num_ - 1); \th = 1 - sqrt((double)(f1 / g)); \tf2 = g * h;  \tind-\u0026gt;obj_[0] = f1; \tind-\u0026gt;obj_[1] = f2; \t}  } In the constructor, it needs to call the Problem's constructor first to set the variable dec_num_, obj_num_ of Problem class and allocate some memories. In addition to this, the decision bound should be set by lower_bound_ and upper_bound_.\nIn the deconstructor, we do nothing because there is no extra memories managed by class ZDT1.\nIn CalObj(Individual* ind), calculating the objective value based on the decision variable ind-\u0026gt;dec_ and set the result to ind-\u0026gt;obj_.\nRegister into EMOC #  Once the declaration and definition has been completed, we need to register the new problem into EMOC. The macro EMOC_REGIST_PROBLEM is provided to simplify the process.\nFirst go to the file \u0026rsquo;/src/problem/problem_head_collect.h\u0026rsquo;, add the new header \u0026lsquo;zdt.h\u0026rsquo;.\n// problem_head_collect.h  #pragma once  ...  // include the new problem header file #include \u0026#34;problem/zdt/zdt.h\u0026#34;And then, open the file \u0026rsquo;/src/problem/problem_head_collect.cpp\u0026rsquo;, add the macro call.\n// problem_head_collect.cpp  #include \u0026#34;problem/problem_head_collect.h\u0026#34; #include \u0026#34;core/macro.h\u0026#34;#include \u0026#34;problem/problem_factory.h\u0026#34; namespace emoc { \t ...  \t// register new problem \tEMOC_REGIST_PROBLEM(Multiobjective, ZDT Series, ZDT1);  } The macro EMOC_REGIST_PROBLEM accept three parameters:\n Problem property: Multiobjective / Singleobjective to declare the property of this problem. Problem category: Custom category name (can be any valid string). Problem name: The name string of problem, must be the same with class name.  After registering and rebuilding, the new problem can be directly used in EMOC with problem name.\nFor deep understand of the structure of EMOC, please go through the section Core Class\n"},{"id":6,"href":"/EMOCDoc/docs/operator/tournament_selection/","title":"Tournament Selection","section":"Operator","content":"Tournament Selection #  File position: /EMOC/src/operator/tournament_selection.h and /EMOC/src/operator/tournament_selection.cpp\n .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }  There are three tournament selection variants in EMOC：\n  Individual* TournamentByRank(Individual* ind1, Individual* ind2)\n  Individual* TournamentByFitness(Individual* ind1, Individual* ind2, int greater_is_better = 0)\n  Individual* TournamentByCustom(Individual* ind1, double ind1_prop, Individual* ind2, double ind2_prop, int greater_is_better = 0)\n  Individual* TournamentByRank(Individual* ind1, Individual* ind2)   Use the non-dominated sorting results (i.e., the rank_ variable of Individual object) to complete the tournament selection.\n Parameter:  ind1: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the first individual which will participate the tournament selection. ind2: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the second individual which will participate the tournament selection.   Returns:  winner: Individual*\u0026nbsp \u0026nbsp The pointer to the individual which win the tournament.     Individual* TournamentByFitness(Individual* ind1, Individual* ind2, int greater_is_better = 0)   Use the the fitness_ variable of Individual object to complete the tournament selection.\n Parameter:  ind1: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the first individual which will participate the tournament selection. ind2: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the second individual which will participate the tournament selection. greater_is_better: int, default=0\u0026nbsp \u0026nbsp Whether the larger fitness the better. By default it's the smaller the better.   Returns:  winner: Individual*\u0026nbsp \u0026nbsp The pointer to the individual which win the tournament.     Individual* TournamentByCustom(Individual* ind1, double ind1_prop, Individual* ind2, double ind2_prop, int greater_is_better = 0)   Use the the custom properties of Individual object to complete the tournament selection.\n Parameter:  ind1: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the first individual which will participate the tournament selection. ind1_prop: double, default=None\u0026nbsp \u0026nbsp The custom property of the first individual ind2: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the second individual which will participate the tournament selection. ind2_prop: double, default=None\u0026nbsp \u0026nbsp The custom property of the second individual greater_is_better: int, default=0\u0026nbsp \u0026nbsp Whether the larger fitness the better. By default it's the smaller the better.   Returns:  winner: Individual*\u0026nbsp \u0026nbsp The pointer to the individual which win the tournament.     "},{"id":7,"href":"/EMOCDoc/docs/extend_emoc/algorithm/","title":"Algorithm","section":"Extend EMOC","content":"Add New Algorithms in EMOC #  Adding a new algorithm is very similar to adding a new problem. We will take NSGA2 as an example (for simplicity, some details are omitted, users can check the complete source code themselves).\nCreate the Declaration #  First, let\u0026rsquo;s go to the directory \u0026rsquo;/src/algorithm/\u0026rsquo;, make a new directory \u0026rsquo;/nsga2\u0026rsquo; and create a header file \u0026rsquo;nsga2.h\u0026rsquo; in it. We make the declaration about class NSGA2 which inherits from class Algorithm in \u0026rsquo;nsga2.h\u0026rsquo;:\n#pragma once #include \u0026#34;core/individual.h\u0026#34;#include \u0026#34;algorithm/algorithm.h\u0026#34;#include \u0026#34;problem/problem.h\u0026#34; #include \u0026lt;vector\u0026gt; namespace emoc {  \tclass NSGA2 : public Algorithm \t{ \tpublic: \tNSGA2(int thread_id); \tvirtual ~NSGA2(); \t\tvoid Solve();  \tprivate: \tvoid Initialization(); \tvoid Crossover(Individual **parent_pop, Individual **offspring_pop); \tvoid EnvironmentalSelection(Individual **parent_pop, Individual **mixed_pop); \t};  } There are three public functions and several private functions in the class. The most important function is Solve() which is a virtual function inherit from parent class Algorithm. We need to implement the details of algorithm in that function and EMOC will call Solve() to optimize the problem.\nCreate the Definition #  After declaring the class NSGA2, the \u0026rsquo;nsga2.cpp\u0026rsquo; file should be created in the same directory. The definition in \u0026rsquo;nsga2.cpp\u0026rsquo; is shown below:\n#include \u0026#34;algorithm/nsga2/nsga2.h\u0026#34; #include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;iostream\u0026gt; #include \u0026#34;core/macro.h\u0026#34;#include \u0026#34;core/global.h\u0026#34;#include \u0026#34;core/nd_sort.h\u0026#34;#include \u0026#34;core/tournament_selection.h\u0026#34;#include \u0026#34;operator/polynomial_mutation.h\u0026#34;#include \u0026#34;operator/sbx.h\u0026#34;#include \u0026#34;random/random.h\u0026#34; namespace emoc {  \tNSGA2::NSGA2(int thread_id) :Algorithm(thread_id) \t{  \t}  \tNSGA2::~NSGA2() \t{  \t}  \tvoid NSGA2::Solve() \t{ \tInitialization(); \twhile (!IsTermination()) \t{ \t// generate offspring population \tCrossover(g_GlobalSettings-\u0026gt;parent_population_.data(), g_GlobalSettings-\u0026gt;offspring_population_.data()); \tPolynomialMutation(g_GlobalSettings-\u0026gt;offspring_population_.data(), 2 * (real_popnum_ / 2), g_GlobalSettings);   // evaluate the offspring population \tEvaluatePop(g_GlobalSettings-\u0026gt;offspring_population_.data(), 2 * (real_popnum_ / 2));   // merge the parent popualtion and offspring population \tMergePopulation(g_GlobalSettings-\u0026gt;parent_population_.data(), real_popnum_, g_GlobalSettings-\u0026gt;offspring_population_.data(), \t2 * (real_popnum_ / 2), g_GlobalSettings-\u0026gt;mixed_population_.data()); \t\t// select next generation\u0026#39;s population \tEnvironmentalSelection(g_GlobalSettings-\u0026gt;parent_population_.data(), g_GlobalSettings-\u0026gt;mixed_population_.data()); \t} \t} } In constructor, the only thing we do is calling the Algorithm's constructor to initialize some variables.\nIn deconstructor, there is nothing to release for NSGA2.\nIn function Solve(), we use some self-defined functions and common utility functions to complete the optimization process.\nRegister into EMOC #  The register of a new algorithm is very straightforward with the aid of macro EMOC_REGIST_ALGORITHM. Go to the file \u0026rsquo;/src/algorithm/algorithm_head_collect.h\u0026rsquo; and add the new header \u0026rsquo;nsga2.h\u0026rsquo; first.\n// algorithm_head_collect.h  #pragma once  ...  // include the new algorithm header file #include \u0026#34;algorithm/nsga2/nsga2.h\u0026#34;And then, open the file \u0026rsquo;/src/algorithm/algorithm_head_collect.cpp\u0026rsquo;, add the macro call.\n// algorithm_head_collect.cpp  #include \u0026#34;algorithm/algorithm_head_collect.h\u0026#34; #include \u0026#34;core/macro.h\u0026#34;#include \u0026#34;algorithm/algorithm_factory.h\u0026#34; namespace emoc {   ...  \t// Register new algorithm \tEMOC_REGIST_ALGORITHM(Multiobjective, Dominance Based, NSGA2);  } The macro EMOC_REGIST_ALGORITHM accept three parameters:\n Algorithm property: Multiobjective / Singleobjective to declare the property of this algorithm. Algorithm category: Custom category name (can be any valid string). Algorithm name: The name string of algorithm, must be the same with class name.  After registering and rebuilding, the new algorithm can be directly used in EMOC with algorithm name.\nFor deep understand of the structure of EMOC, please go through the section Core Class\n"},{"id":8,"href":"/EMOCDoc/docs/quickstart/command_line_mode/","title":"Command Line Mode","section":"Quick Start","content":"Command Line Mode #  Except using EMOC in the GUI mode, we also provide command line (CMD) mode for these users who don\u0026rsquo;t have a display screen for some reasons(like on a remote server).\nA Simple Case #  Go to the directory of executable file and open the terminal. Users can run EMOC with default parameters by just:\n./EMOC For windows, change the \u0026rsquo;./EMOC\u0026rsquo; to \u0026lsquo;EMOC.exe\u0026rsquo;. Some settings and results information will be printed in the terminal:\n(Note: If you want to calculate the indicator values of optimization results, the executable file should in the same directory with \u0026rsquo;/pf_data\u0026rsquo;.)\nAfter executing, the optimized population results will be saved in /output/test_module/ directory.\nRun EMOC with Different Parameters #  In CMD mode, users can also set different parameters of this run, an example is shown below:\n./EMOC --algorithm MOEADDE --problem DTLZ1 --evaluation 25000 -N 100 this command sets the algorithm to MOEADDE, the problem to DTLZ1, the max evaluation to 25000 and the population number to 100. All acceptable parameters are listed in the following table:\n   Parameter Name Description Default Value     -h, --help Print some helpful information in the terminal None   -g, --gui Run EMOC in GUI mode False   -a, --algorithm Algorithm name NSGA2   -p, --problem Problem name ZDT1   -N, --pop Population size 100   -m, --obj Problem\u0026rsquo;s objective dimension 2   -n, --dec Problem\u0026rsquo;s decision variable dimension 30   -e, --evaluation Max evaluation number for each run 25000   -i, --interval Population save interval in generation 100   -r, --run The number of runs 1   --multithread Whether to use multi-thread False   -t, --thread Thread number (only valid when using multi-thread) 4    Available Algorithms and Problems #  The available algorithms and problems in EMOC are listed below.\nAlgorithms：\n   Decomposition Based Dominance Based Indicator Based Constraint Single Objective     MOEAD NSGA2 IBEA CNSGA2 GA   MOEADDE NSGA3 HypE CMOEAD DifferentialEvolution   MOEADDRA SPEA2 SMSEMOA CTAEA SA   MOEADGRA SPEA2SDE      MOEADIRA tDEA      ENSMOEAD       MOEADCDE       MOEADSTM       MOEADPAS       MOEADM2M       MOEADD       MOEADDYTS       MOEADFRRMAB       MOEADUCB       RVEA        Problems:\n   Single Objective Multi Objective Many Objective Constraint     Sphere ZDT Series DTLZ Series CDTLZ Series   Ackley UF Series MinusDTLZ Series DCDTLZ Series   Rastrigin BT Series MDTLZ Series    TSP MOEADDE_F Series WFG Series    Knapsack IMMOEA_F Series LSMOP Series     MOEADM2M_F Series      "},{"id":9,"href":"/EMOCDoc/docs/indicator/gd_plus/","title":"Generational Distance Plus","section":"Indicator","content":"Generational Distance Plus #  File position: /EMOC/src/metric/gd_plus.h and /EMOC/src/metric/gd_plus.cpp\n .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }   double CalculateGDPlus(Individual** pop, int pop_num, int obj_num, double** pf_data, int pf_size)   Calculate the generational distance plus value of current population pop based on the pareto front data pf_data.\n Parameter:  pop: Individual**, default=None\u0026nbsp \u0026nbsp The population which need to be initialized. It's an array of Individual* where each Individual* is a pointer to a individual in the population. pop_num: int, default=None\u0026nbsp \u0026nbsp The size of the given population. obj_num: int, default=None\u0026nbsp \u0026nbsp The number of objectives. pf_data: double**, default=None\u0026nbsp \u0026nbsp The pareto front data. It's a 2D array of double (pf_size X obj_num). pf_size: int, default=None\u0026nbsp \u0026nbsp The size of the pareto front pf_data.   Returns:  gdplus_value: double\u0026nbsp \u0026nbsp Generational distance plus value of current population pop.     "},{"id":10,"href":"/EMOCDoc/docs/core_class/individual/","title":"Individual","section":"Core Class","content":"Individual Class #  File position: /EMOC/src/core/individual.h and /EMOC/src/core/individual.cpp\nclass Individual(int dec_num, int obj_num)  The class for each individual in the population.\n .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }    Parameter:   dec_num: int, default=None\u0026nbsp \u0026nbsp The number of decision variables. obj_num: int, default=None\u0026nbsp \u0026nbsp The number of objectives.   Member variables:  (public) dec_: std::vector\u0026ltdouble\u0026gt\u0026nbsp \u0026nbsp Decision variables of this individual. The size of this std::vector is dec_num.  (public) obj_: std::vector\u0026ltdouble\u0026gt\u0026nbsp \u0026nbsp Objectives of this individual. The size of this std::vector is obj_num. (public) con_: std::vector\u0026ltdouble\u0026gt\u0026nbsp \u0026nbsp Constraints of this individual. The size of this std::vector is obj_num. (public) fitness_: double\u0026nbsp \u0026nbsp The fitness of this individual. (public) rank_: int\u0026nbsp \u0026nbsp The rank index of this individual in the non-dominated sort (NDS) results of current population. Rank 0 represents the first front in NDS.     "},{"id":11,"href":"/EMOCDoc/docs/operator/sbx/","title":"Simulated Binary Crossover","section":"Operator","content":"Simulated Binary Crossover #  File position: /EMOC/src/operator/sbx.h and /EMOC/src/operator/sbx.cpp\n .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }   void SBX(Individual* parent1, Individual* parent2, Individual* offspring1, Individual* offspring2, std::vector\u0026lt;double\u0026gt;\u0026amp; lower_bound, std::vector\u0026lt;double\u0026gt;\u0026amp; upper_bound, CrossoverParameter\u0026amp; cross_para)   Do the simulated binary crossover based on parent1 and parent2, the results are stored in offspring1 and offspring2.\n Parameter:  parent1: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the first parent individual to do simulated binary crossover. parent2: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the second parent individual to do simulated binary crossover. offspring1: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the first offspring individual of simulated crossover results. The memory of the offspring need to be allocated outside the function. offspring2: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the second offspring individual of simulated crossover results. The memory of the offspring need to be allocated outside the function. lower_bound: std::vector\u0026ltdouble\u0026gt, default=None\u0026nbsp \u0026nbsp The lower boundary of decision variables. upper_bound: std::vector\u0026ltdouble\u0026gt, default=None\u0026nbsp \u0026nbsp The upper boundary of decision variables. cross_para: CrossoverParameter, default=None\u0026nbsp \u0026nbsp The parameter of this crossover. The type CrossoverParameter is just a simple structure which has three member variables (i.e., the crossover probability, the distribution index1 and the distribution index2)   Returns:  void     "},{"id":12,"href":"/EMOCDoc/docs/utility_function/uniform_weight_vector/","title":"Uniform Weight Vector Generation","section":"Utility Function","content":"Uniform Weight Vector Generation #  File position: /EMOC/src/core/uniform_point.h and /EMOC/src/core/uniform_point.cpp\n .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }   double** UniformPoint(int num, int* weight_num, int obj_num)   Generate uniform weight vectors.\n Parameter:  num: int, default=None\u0026nbsp \u0026nbsp Number of uniform weight vectors want to generate. weight_num: int*, default=None\u0026nbsp \u0026nbsp The real number of generated weight vectors. obj_num: int, default=None\u0026nbsp \u0026nbsp The dimension of generated weight vectors.   Returns:  lambda: double**\u0026nbsp \u0026nbsp Generated uniform weight vectors. It's a 2D array of double with the size weight_num X obj_num.     "},{"id":13,"href":"/EMOCDoc/docs/utility_function/aggregation_functions/","title":"Aggregation Functions","section":"Utility Function","content":"Aggregation Functions #  File position: /EMOC/src/core/utility.h and /EMOC/src/core/utility.cpp\n .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }  There are several aggregation functions for decomposition:\n  double CalWeightedSum(Individual *ind, double *weight_vector, double *ideal_point, int obj_num)\n  double CalInverseChebycheff(Individual *ind, double *weight_vector, double *ideal_point, int obj_num)\n  double CalPBI(Individual *ind, double *weight_vector, double *ideal_point, int obj_num, double theta)\n  double CalWeightedSum(Individual *ind, double *weight_vector, double *ideal_point, int obj_num)   Use weighted sum method to decompose the individual ind based on weight vector weight_vector.\n Parameter:  ind: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the individual which will be decomposed. weight_vector: double*, default=None\u0026nbsp \u0026nbsp The weight vector for decomposition. It's a 1D array of double. obj_num: int, default=None\u0026nbsp \u0026nbsp The number of objectives.   Returns:  weighted_sum: double\u0026nbsp \u0026nbsp The decomposition value with the weighted sum method.     double CalInverseChebycheff(Individual *ind, double *weight_vector, double *ideal_point, int obj_num)   Use inverse chebycheff method to decompose the individual ind based on weight vector weight_vector.\n Parameter:  ind: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the individual which will be decomposed. weight_vector: double*, default=None\u0026nbsp \u0026nbsp The weight vector for decomposition. It's a 1D array of double. ideal_point: double*, default=None\u0026nbsp \u0026nbsp The ideal point of current population. It's a 1D array of double. obj_num: int, default=None\u0026nbsp \u0026nbsp The number of objectives.   Returns:  inverse_chebycheff: double\u0026nbsp \u0026nbsp The decomposition value with the inverse chebycheff method.     double CalPBI(Individual *ind, double *weight_vector, double *ideal_point, int obj_num, double theta)   Use penalty-based boundary intersection method to decompose the individual ind based on weight vector weight_vector.\n Parameter:  ind: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the individual which will be decomposed. weight_vector: double*, default=None\u0026nbsp \u0026nbsp The weight vector for decomposition. It's a 1D array of double. ideal_point: double*, default=None\u0026nbsp \u0026nbsp The ideal point of current population. It's a 1D array of double. obj_num: int, default=None\u0026nbsp \u0026nbsp The number of objectives. theta: double, default=None\u0026nbsp \u0026nbsp The parameter of penalty-based boundary intersection method.   Returns:  pbi: double\u0026nbsp \u0026nbsp The decomposition value with the penalty-based boundary intersection method.     "},{"id":14,"href":"/EMOCDoc/docs/operator/de/","title":"Differential Evolution","section":"Operator","content":"Differential Evolution #  File position: /EMOC/src/operator/de.h and /EMOC/src/operator/de.cpp\n .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }   void DE(Individual *parent1, Individual *parent2, Individual *parent3, Individual *offspring, std::vector\u0026lt;double\u0026gt;\u0026amp; lower_bound, std::vector\u0026lt;double\u0026gt;\u0026amp; upper_bound, CrossoverParameter\u0026amp; cross_para)   Do the differential evolution on parent1 , parent2 and parent3, the results are stored in offspring.\n Parameter:  parent1: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the first parent individual to do differential evolution. parent2: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the second parent individual to do differential evolution. parent3: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the third parent individual to do differential evolution. offspring: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the offspring individual of differential evolution results. The memory of the offspring need to be allocated outside the function. lower_bound: std::vector\u0026ltdouble\u0026gt, default=None\u0026nbsp \u0026nbsp The lower boundary of decision variables. upper_bound: std::vector\u0026ltdouble\u0026gt, default=None\u0026nbsp \u0026nbsp The upper boundary of decision variables. cross_para: CrossoverParameter, default=None\u0026nbsp \u0026nbsp The parameter of this crossover. The type CrossoverParameter is just a simple structure which has three member variables (i.e., the crossover probability, the distribution index1 and the distribution index2).   Returns:  void     "},{"id":15,"href":"/EMOCDoc/docs/indicator/igd/","title":"Inverted Generational Distance","section":"Indicator","content":"Inverted Generational Distance #  File position: /EMOC/src/metric/igd.h and /EMOC/src/metric/igd.cpp\n .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }   double CalculateIGD(Individual** pop, int pop_num, int obj_num, double** pf_data, int pf_size)   Calculate the inverted generational distance value of current population pop based on the pareto front data pf_data.\n Parameter:  pop: Individual**, default=None\u0026nbsp \u0026nbsp The population which need to be initialized. It's an array of Individual* where each Individual* is a pointer to a individual in the population. pop_num: int, default=None\u0026nbsp \u0026nbsp The size of the given population. obj_num: int, default=None\u0026nbsp \u0026nbsp The number of objectives. pf_data: double**, default=None\u0026nbsp \u0026nbsp The pareto front data. It's a 2D array of double (pf_size X obj_num). pf_size: int, default=None\u0026nbsp \u0026nbsp The size of the pareto front pf_data.   Returns:  igd_value: double\u0026nbsp \u0026nbsp Inverted generational distance value of current population pop.     "},{"id":16,"href":"/EMOCDoc/docs/core_class/problem/","title":"Problem","section":"Core Class","content":"Problem Class #  File position: /EMOC/src/problem/problem.h and /EMOC/src/problem/problem.cpp\nclass Problem(int dec_num, int obj_num)  The parent class of all test problems in EMOC.\n .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }    Parameter:   dec_num: int, default=None\u0026nbsp \u0026nbsp The number of decision variables setting for the problem. obj_num: int, default=None\u0026nbsp \u0026nbsp The number of objective functions setting for the problem.   Member variables:  (public) dec_num_: int\u0026nbsp \u0026nbsp The number of decision variables set by users. It is equal to the given dec_num.  (public) obj_num_: int\u0026nbsp \u0026nbsp The number of objective functions set by users. It is equal to the given obj_num. (public) lower_bound_: std::vector\u0026ltdouble\u0026gt\u0026nbsp \u0026nbsp The lower bound of each decision variable. The size of this std::vector is dec_num. (public) upper_bound_: std::vector\u0026ltdouble\u0026gt\u0026nbsp \u0026nbsp The upper bound of each decision variable. The size of this std::vector is dec_num. (public) encoding_: enum of EncodingType\u0026nbsp \u0026nbsp Encoding type of solutions in this problem. There are three different types: REAL, BINARY and PERMUTATION which corresponds to real encoding, binary encoding, permutation encoding respectively.       Public Member Functions:\n void CalObj(Individual* ind) void CalCon(Individual* ind)  void CalObj(Individual* ind)   Calculate the objective function values.\nThis function is a pure virtual function which must be implemented in subclass.\n Parameter:  ind: Individual*, default=None\u0026nbsp \u0026nbsp Pointer to the individual which need to calculate the objectives.   Returns:  void     void CalCon(Individual* ind)   Calculate the constraint function values.\nThis function is a virtual function which can be implemented in subclass. It has an empty implementation by default. So users can leave it alone when implementing test problems without constraints.\n  Parameter:   ind: Individual*, default=None\u0026nbsp \u0026nbsp Pointer to the individual which need to calculate the constraints.   Returns:  void     "},{"id":17,"href":"/EMOCDoc/docs/quickstart/use_emoc_in_python/","title":"Use EMOC in Python","section":"Quick Start","content":"Use EMOC in Python #  To increase the flexibility of EMOC, we also provide a method to compile the source code to a python dynamic link library (DLL). So that EMOC can be used in python language too.\nBuild #  EMOC project provides script files on different platforms for the ease of building.\nOpen your platform\u0026rsquo;s script file with a text editor and find the row begin with cmake -DBUILD_PYTHON_DLL=OFF. Change the OFF to ON. For example:\n# build_linux.sh  # download dependencies sudo apt install gnuplot gnuplot-x11 sudo apt install xorg-dev sudo apt install mesa-common-dev libgl1-mesa-dev  # build EMOC mkdir build cd build cmake -DBUILD_PYTHON_DLL=ON .. make -j4 The following build steps are the same as we talked in Install section, just execute the script file directly. After building successfully, the DLL file \u0026lsquo;EMOC.xxxx.so\u0026rsquo; (or \u0026lsquo;EMOC.xxxx.pyd\u0026rsquo; on windows) will appear in \u0026rsquo;/build\u0026rsquo; directory. Rename it to \u0026lsquo;EMOC.so\u0026rsquo; (or \u0026lsquo;EMOC.pyd\u0026rsquo;) and put it with your python file.\nCustom Problem #  Users can define their own problems in python like this:\nimport EMOC import numpy as np  class MyUF1(EMOC.Problem):  def __init__(self, dec_num, obj_num):  super(MyUF1, self).__init__(dec_num,obj_num)  lower_bound = [-1] * dec_num  lower_bound[0] = 0  self.lower_bound = lower_bound  self.upper_bound = [1] * dec_num   def CalObj(self, ind):  x = ind.dec  temp_obj = [0] * self.obj_num  # print(\u0026#34;here\\n\u0026#34;)  sum1 = 0  count1 = 0  sum2 = 0  count2 = 0  for i in range(2,self.dec_num+1):  yj = x[i-1] - np.sin(6.0 * np.pi * x[0] + i * np.pi / self.dec_num)  yj = yj * yj  if i % 2 == 0:  sum2 += yj  count2 = count2 + 1  else:  sum1 += yj  count1 += 1  temp_obj[0] = x[0] + 2.0 * sum1 / count1  temp_obj[1] = 1.0 - np.sqrt(x[0]) + 2.0 * sum2 / count2  ind.obj = temp_obj First of all, the custom problem need to inherit from EMOC.Problem. And in the constructor function, you should call the EMOC.Problem's constructor first and set the decision bound of problem. In addition to this, the CalObj(self, ind) function should be implemented to calculate the objective of your problem. You can get the decision variable from ind.dec and set the objective by ind.obj.\n(Note: The decision bound and ind.obj are all arrays, they should be set as a whole for communicating between Python and C++.)\nOptimization with EMOC #  When the custom problem has been defined, one can use EMOC to optimize it.\n# create and set EMOC parameters para = EMOC.EMOCParameters() para.algorithm_name = \u0026#34;MOEADDE\u0026#34; para.problem_name = \u0026#34;UF1\u0026#34; para.population_num = 100 para.decision_num = 7 para.objective_num = 2 para.max_evaluation = 25000 para.output_interval = 10000  # set customized problem (optional) myProblem = MyUF1(para.decision_num,para.objective_num) para.SetProblem(myProblem)  # create EMOCManager instance and run it EMOCManager = EMOC.EMOCManager() EMOCManager.SetTaskParameters(para) EMOCManager.Run()  # get the optimization results result = EMOCManager.GetResult() print(\u0026#34;Population Number: \u0026#34;,result.pop_num) print(\u0026#34;Population Decisions: \u0026#34;,result.pop_decs) print(\u0026#34;Population Objectives: \u0026#34;,result.pop_objs) First create a EMOC.EMOCParameters object para , set the algorithm you want to use and parameters for this optimization. If users have defined their own problems, create the problem object and set it into the para by para.SetProblem(). Note this will disable the original test problem settings in para.problem_name.\nFinally, create an EMOC.EMOCManager object EMOCManager, set the task parameters and call the function EMOCManager.Run(). The optimization results can be retrieved by EMOCManager.GetResult().\nFor information about the EMOC related classes, please refer to section Python DLL.\n"},{"id":18,"href":"/EMOCDoc/docs/core_class/algorithm/","title":"Algorithm","section":"Core Class","content":"Algorithm Class #  File position: /EMOC/src/algorithm/algorithm.h and /EMOC/src/algorithm/algorithm.cpp\nclass Algorithm(int thread_id)  The parent class of all algorithms in EMOC. It provides some useful functions for subclasses such as population evaluation and copy.\n .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }    Parameter:   thread_id: int, default=0\u0026nbsp \u0026nbsp Index of current thread index. EMOC reserved an array of Global objects. Each object is owned by an unique thread. This index is used to refer to the correpsonding Global object for algorithm class to get some current run's settings easily.   Member variables:  (protected) g_GlobalSettings: Global*\u0026nbsp \u0026nbsp The pointer to the Global object set according to thread_id. It is used to retrieve the parameter settings directly in algorithm implementations when necessary. (protected) thread_id_: int\u0026nbsp \u0026nbsp The index of current thread. It is equal to the given thread_id_. (protected) real_popnum_: int\u0026nbsp \u0026nbsp The size of the optimized population. Note that the population size may not eaqual to the setting number when using decomposition based algorithms.  (protected) runtime_: double\u0026nbsp \u0026nbsp Total time for the algorithm to optimize the problem.      Public Methods:\n void Solve() void PrintPop() int GetRealPopNum() double GetRuntime()  void Solve()   Optimization process of the algorithm.\nIt is a pure virtual function which must be implemented in subclass.\n  Parameter:   void   Returns:  void     void PrintPop()   Display the population information in the screen.\n Parameter:  void   Returns:  void     int GetRealPopNum()   Get the real size of population.\n Parameter:  void   Returns:  real_popnum_: int\u0026nbsp \u0026nbsp The size of the current population.     double GetRuntime()   Get the runtime of current run.\n Parameter:  void   Returns:  runtime_: double\u0026nbsp \u0026nbsp Total time for the algorithm to optimize the problem.      Protected Methods:\n bool IsTermination() void EvaluateInd(Individual *ind) void EvaluatePop(Individual **pop, int pop_num) void SwapIndividual(Individual* ind1, Individual* ind2) void CopyIndividual(Individual* ind_src, Individual* ind_dest) int MergePopulation(Individual** pop_src1, int pop_num1, Individual** pop_src2, int pop_num2, Individual** pop_dest)  bool IsTermination()   Get the execution state of current run.\n Parameter:  void   Returns:  is_terminated: bool\u0026nbsp \u0026nbsp Whether the execution is terminated.     void EvaluateInd(Individual* ind)   Evaluate the given individual.\n Parameter:  ind: Individual *, default=None\u0026nbsp \u0026nbsp The pointer to the individual which need to be evaluated.   Returns:  void     void EvaluatePop(Individual** pop, int pop_num)   Evaluate the given population\n Parameter:  pop: Individual**, default=None\u0026nbsp \u0026nbsp The population which need to be evaluated. It's an array of Individual* where each Individual* is a pointer to a individual in the population. pop_num: int, default=None\u0026nbsp \u0026nbsp The size of the given population.   Returns:  void     void SwapIndividual(Individual* ind1, Individual* ind2)   Swap the two given individual.\n Parameter:  ind1: Individual*, default=None\u0026nbsp \u0026nbsp Pointer to the first individual. ind2: Individual*, default=None\u0026nbsp \u0026nbsp Pointer to the second individual.   Returns:  void     void CopyIndividual(Individual* ind_src, Individual* ind_dest)   Copy the individual ind_src to the indvidual ind_dest.\n Parameter:  ind_src: Individual*, default=None\u0026nbsp \u0026nbsp Pointer to the source individual. ind_dest: Individual*, default=None\u0026nbsp \u0026nbsp Pointer to the destination individual.   Returns:  void     int MergePopulation(Individual** pop_src1, int pop_num1, Individual** pop_src2, int pop_num2, Individual** pop_dest)   Get the runtime of current run.\n Parameter:  pop_src1: Individual**, default=None\u0026nbsp \u0026nbsp First source population. It's an array of Individual* where each Individual* is a pointer to a individual in the population. pop_num1: int, default=None\u0026nbsp \u0026nbsp Size of the first source population. pop_src2: Individual**, default=None\u0026nbsp \u0026nbsp Second source population. It's an array of Individual* where each Individual* is a pointer to a individual in the population. pop_num2: int, default=None\u0026nbsp \u0026nbsp Size of the second source population. pop_dest: Individual**, default=None\u0026nbsp \u0026nbsp Destination population. It's an array of Individual* where each Individual* is a pointer to a individual in the population.   Returns:  mixed_popnum: int\u0026nbsp \u0026nbsp Size of the mixed population.     "},{"id":19,"href":"/EMOCDoc/docs/indicator/igd_plus/","title":"Inverted Generational Distance Plus","section":"Indicator","content":"Inverted Generational Distance Plus #  File position: /EMOC/src/metric/igd_plus.h and /EMOC/src/metric/igd_plus.cpp\n .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }   double CalculateIGDPlus(Individual** pop, int pop_num, int obj_num, double** pf_data, int pf_size)   Calculate the inverted generational distance plus value of current population pop based on the pareto front data pf_data.\n Parameter:  pop: Individual**, default=None\u0026nbsp \u0026nbsp The population which need to be initialized. It's an array of Individual* where each Individual* is a pointer to a individual in the population. pop_num: int, default=None\u0026nbsp \u0026nbsp The size of the given population. obj_num: int, default=None\u0026nbsp \u0026nbsp The number of objectives. pf_data: double**, default=None\u0026nbsp \u0026nbsp The pareto front data. It's a 2D array of double (pf_size X obj_num). pf_size: int, default=None\u0026nbsp \u0026nbsp The size of the pareto front pf_data.   Returns:  igdplus_value: double\u0026nbsp \u0026nbsp Inverted generational distance plus value of current population pop.     "},{"id":20,"href":"/EMOCDoc/docs/utility_function/sampling_functions/","title":"Sampling Functions","section":"Utility Function","content":"Sampling Functions #   .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }  Random Number Generation #  File position: /EMOC/vendor/random.h and /EMOC/vendor/random.cpp\nRandom number generation is a basic function for evolutionary algorithm, EMOC provides several random number related functions as below:\n double randomperc() int rnd(int low, int high) double rndreal(double low, double high)  double randomperc()   Fetch a single random number between 0.0 and 1.0.\n Parameter:  void   Returns:  rand: double\u0026nbsp \u0026nbsp A random number between 0.0 and 1.0.     int rnd(int low, int high)   Return a random integer between low and high.\n Parameter:  low: int, default=None\u0026nbsp \u0026nbsp Lower boundary of random integer. high: int, default=None\u0026nbsp \u0026nbsp Upper boundary of random integer.   Returns:  rand: double\u0026nbsp \u0026nbsp A random integer between low and high.     double rndreal(double low, double high)   Return a random real number between low and high.\n Parameter:  low: double, default=None\u0026nbsp \u0026nbsp Lower boundary of random double. high: double, default=None\u0026nbsp \u0026nbsp Upper boundary of random double.   Returns:  rand: double\u0026nbsp \u0026nbsp A random double between low and high.     Sampling from Distribution #  File position: /EMOC/src/core/utility.h and /EMOC/src/core/utility.cpp\nThere are also some sampling function for different distribution:\n  double CauchyRandom(double location, double scale)\n  double BetaRandom(double a, double b)\n  double GaussianRandom(double mean, double stdev)\n  double CauchyRandom(double location, double scale)   Return a sample value subject to Cauchy distribution.\n Parameter:  location: double, default=None\u0026nbsp \u0026nbsp The location parameter of Cauchy distribution. scale: double, default=None\u0026nbsp \u0026nbsp The scale parameter of Cauchy distribution.   Returns:  sample: double\u0026nbsp \u0026nbsp A random sample from Cauchy distribution.     double BetaRandom(double a, double b)   Return a sample value subject to Beta distribution.\n Parameter:  a: double, default=None\u0026nbsp \u0026nbsp The alpha parameter of Beta distribution. b: double, default=None\u0026nbsp \u0026nbsp The beta parameter of Beta distribution.   Returns:  sample: double\u0026nbsp \u0026nbsp A random sample from Beta distribution.     double GaussianRandom(double mean, double stdev)   Return a sample value subject to Gaussian distribution.\n Parameter:  mean: double, default=None\u0026nbsp \u0026nbsp The mean parameter of Gaussian distribution. stdev: double, default=None\u0026nbsp \u0026nbsp The standard deviation parameter of Gaussian distribution.   Returns:  sample: double\u0026nbsp \u0026nbsp A random sample from Gaussian distribution.     "},{"id":21,"href":"/EMOCDoc/docs/operator/uniform_crossover/","title":"Uniform Crossover","section":"Operator","content":"Uniform Crossover #  File position: /EMOC/src/operator/uniform_crossover.h and /EMOC/src/operator/uniform_crossover.cpp\n .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }   void UniformCrossover(Individual *parent1, Individual *parent2, Individual *offspring1, Individual *offspring2)   Do the uniform crossover on parent1 and parent2, the results are stored in offspring1 and offspring2. Note this crossover is for binary encoding problems.\n Parameter:  parent1: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the first parent individual to do uniform crossover. parent2: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the second parent individual to do uniform crossover. offspring1: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the first offspring individual of uniform crossover results. The memory of the offspring need to be allocated outside the function. offspring2: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the second offspring individual of uniform crossover results. The memory of the offspring need to be allocated outside the function.   Returns:  void     "},{"id":22,"href":"/EMOCDoc/docs/core_class/global/","title":"Global","section":"Core Class","content":"Global Class #  File position: /EMOC/src/core/global.h and /EMOC/src/core/global.cpp\nclass Global(const char* algorithm_name, const char* problem_name, int population_num, int dec_num, int obj_num, int max_evaluation, int thread_id, int output_interval, int run_id = 0)  Global class represents an execution entity of EMOC which basically is a specified algorithm optimized a certain problem with pre-defined parameters. It holds all the relevant datas such as the pointer to algorithm, the pointer to problem, optimization settings and the population.\n .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }    Parameter:   algorithm_name: const char*, default=None\u0026nbsp \u0026nbsp The name of the specified algorithm. problem_name: const char*, default=None\u0026nbsp \u0026nbsp The name of the specified problem. population_num: int, default=None\u0026nbsp \u0026nbsp The number of population size. dec_num: int, default=None\u0026nbsp \u0026nbsp The number of the decision variables for problem settings. obj_num: int, default=None\u0026nbsp \u0026nbsp The number of objective functions for problem settings. max_evaluation: int, default=None\u0026nbsp \u0026nbsp The max evaluation times for current run. thread_id: int, default=None\u0026nbsp \u0026nbsp The index of used thread. If there is no multi-thread enabled, 0 will be used.  output_interval: int, default=None\u0026nbsp \u0026nbsp The interval of population saving in generation. run_id: int, default=0\u0026nbsp \u0026nbsp The index of current run. This is for multiple runs with same parameter settings, starting from 0.   Member variables:  (public) dec_num_: int\u0026nbsp \u0026nbsp The number of the decision variables. It is equal to the given dec_num. (public) obj_num_: int\u0026nbsp \u0026nbsp The number of objectives. It is equal to the given obj_num. (public) population_num_: int\u0026nbsp \u0026nbsp The number of population size. It is equal to the given population_num. (public) max_evaluation_: int\u0026nbsp \u0026nbsp The max evaluation times. It is equal to the given max_evaluation. (public) output_interval_: int\u0026nbsp \u0026nbsp The interval of population saving in generation. It is equal to the given output_interval. (public) algorithm_name_: std::string\u0026nbsp \u0026nbsp The name of the specified algorithm. It is equal to the given algorithm_name. (public) problem_name_: std::string\u0026nbsp \u0026nbsp The name of the specified problem. It is equal to the given problem_name. (public) iteration_num_: int\u0026nbsp \u0026nbsp The iteration index. It is updated by the algorithm in it's optimization loop. (public) current_evaluation_: int\u0026nbsp \u0026nbsp Current evaluation times. It is updated when the individual is evaluated. (public) algorithm_: Algorithm*\u0026nbsp \u0026nbsp Pointer to the current run's algorithm object. (public) problem_: Problem*\u0026nbsp \u0026nbsp Pointer to the current run's problem object. (public) dec_lower_bound_: std::vector\u0026ltdouble\u0026gt\u0026nbsp \u0026nbsp Lower bound for each decision variables. (public) dec_upper_bound_: std::vector\u0026ltdouble\u0026gt\u0026nbsp \u0026nbsp Upper bound for each decision variables. (public) parent_population_: std::vector\u0026ltIndividual*\u0026gt\u0026nbsp \u0026nbsp The parent population of current run. (public) offspring_population_: std::vector\u0026ltIndividual*\u0026gt\u0026nbsp \u0026nbsp The offspring population of current run. (public) mixed_population_: std::vector\u0026ltIndividual*\u0026gt\u0026nbsp \u0026nbsp The mixed population of current run. It is usually used to do some merge work.      Public Methods:\n  void Init()\n  void Start()\n  void InitializeIndividual(Individual* ind)\n  void InitializePopulation(Individual** pop, int pop_num)\n  void Init()   Initialize the Global object such as setting the parameters\u0026rsquo; value and allocating memories.\n Parameter:  void   Returns:  void     void Start()   Start the optimization with current configuration.\n  Parameter:   void   Returns:  void     void InitializeIndividual(Individual* ind)   Initialize the given individual (i.e. set the decision variables with uniform random number in the decision bounds).\n Parameter:  ind: Individual *, default=None\u0026nbsp \u0026nbsp The pointer to the individual which need to be initialized.   Returns:  void     void InitializePopulation(Individual** pop, int pop_num)   Initialize the given population.\n Parameter:  pop: Individual**, default=None\u0026nbsp \u0026nbsp The population which need to be initialized. It's an array of Individual* where each Individual* is a pointer to a individual in the population. pop_num: int, default=None\u0026nbsp \u0026nbsp The size of the given population.   Returns:  void     "},{"id":23,"href":"/EMOCDoc/docs/indicator/hv/","title":"Hypervolume","section":"Indicator","content":"Hypervolume #  File position: /EMOC/src/metric/hv.h and /EMOC/src/metric/hv.cpp\nDue to the complexity of calculating hypervolume, we use a class to encapsulate the details into a class HVCalculator. The most important public interface is the following:\n .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }   double HVCalculator::Calculate(Individual** pop, int pop_num, int obj_num, double** pf_data, int pf_size)   Calculate the hypervolume value of current population pop based on the pareto front data pf_data.\n Parameter:  pop: Individual**, default=None\u0026nbsp \u0026nbsp The population which need to be initialized. It's an array of Individual* where each Individual* is a pointer to a individual in the population. pop_num: int, default=None\u0026nbsp \u0026nbsp The size of the given population. obj_num: int, default=None\u0026nbsp \u0026nbsp The number of objectives. pf_data: double**, default=None\u0026nbsp \u0026nbsp The pareto front data. It's a 2D array of double (pf_size X obj_num). pf_size: int, default=None\u0026nbsp \u0026nbsp The size of the pareto front pf_data.   Returns:  hv_value: double\u0026nbsp \u0026nbsp Hypervolume value of current population pop.     "},{"id":24,"href":"/EMOCDoc/docs/utility_function/math_related_functions/","title":"Math Related Functions","section":"Utility Function","content":"Math Related Functions #  File position: /EMOC/src/core/utility.h and /EMOC/src/core/utility.cpp\n .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }  In EMOC, some mathematic operations are also provided for convenience:\n  int Combination(int n, int k)\n  double CalculateCos(double *a, double *b, int dimension)\n  double CalculateSin(double *a, double *b, int dimension)\n  double CalculateNorm(double *vector, int dimension)\n  double CalculateDotProduct(double *vector1, double *vector2, int dimension)\n  double CalEuclidianDistance(double* a, double* b, int dimension)\n  double CalPerpendicularDistance(double* a, double* b, int dimension)\n  int Combination(int n, int k)   Return the combination number with the given parameters.\n Parameter:  n: int, default=None\u0026nbsp \u0026nbsp The number of total things. k: int, default=None\u0026nbsp \u0026nbsp The number of things taken from the total n things.   Returns:  combination: double\u0026nbsp \u0026nbsp Combination number.     double CalculateCos(double *a, double *b, int dimension)   Calculate the cosine value between two vectors.\n Parameter:  a: double*, default=None\u0026nbsp \u0026nbsp The first vector. It's a 1D array of double. b: double*, default=None\u0026nbsp \u0026nbsp The second vector. It's a 1D array of double. dimension: int, default=None\u0026nbsp \u0026nbsp The dimension of given vectors.   Returns:  cos: double\u0026nbsp \u0026nbsp Cosine value between vector a and vector b.     double CalculateSin(double *a, double *b, int dimension)   Calculate the sine value between two vectors.\n Parameter:  a: double*, default=None\u0026nbsp \u0026nbsp The first vector. It's a 1D array of double. b: double*, default=None\u0026nbsp \u0026nbsp The second vector. It's a 1D array of double. dimension: int, default=None\u0026nbsp \u0026nbsp The dimension of given vectors.   Returns:  sin: double\u0026nbsp \u0026nbsp Sine value between vector a and vector b.     double CalculateNorm(double *vector, int dimension)   Calculate the norm of given vector.\n Parameter:  vector: double*, default=None\u0026nbsp \u0026nbsp The pointer to given vector. It's a 1D array of double. dimension: int, default=None\u0026nbsp \u0026nbsp The dimension of given vector.   Returns:  norm: double\u0026nbsp \u0026nbsp The norm of given vector.     double CalculateDotProduct(double *vector1, double *vector2, int dimension)   Calculate the dot product between two vectors.\n Parameter:  vector1: double*, default=None\u0026nbsp \u0026nbsp The first vector. It's a 1D array of double. vector2: double*, default=None\u0026nbsp \u0026nbsp The second vector. It's a 1D array of double. dimension: int, default=None\u0026nbsp \u0026nbsp The dimension of given vectors.   Returns:  sin: double\u0026nbsp \u0026nbsp Dot product between the two given vectors.     double CalEuclidianDistance(double* a, double* b, int dimension)   Calculate the euclidian distance between two vectors.\n Parameter:  a: double*, default=None\u0026nbsp \u0026nbsp The first vector. It's a 1D array of double. b: double*, default=None\u0026nbsp \u0026nbsp The second vector. It's a 1D array of double. dimension: int, default=None\u0026nbsp \u0026nbsp The dimension of given vectors.   Returns:  distance: double\u0026nbsp \u0026nbsp The euclidian distance between two vectors.     double CalPerpendicularDistance(double* a, double* b, int dimension)   Calculate the perpendicular distance between two vectors.\n Parameter:  a: double*, default=None\u0026nbsp \u0026nbsp The first vector. It's a 1D array of double. b: double*, default=None\u0026nbsp \u0026nbsp The second vector. It's a 1D array of double. dimension: int, default=None\u0026nbsp \u0026nbsp The dimension of given vectors.   Returns:  perpendicular: double\u0026nbsp \u0026nbsp The euclidian distance between two vectors.     "},{"id":25,"href":"/EMOCDoc/docs/operator/order_crossover/","title":"Order Crossover","section":"Operator","content":"Order Crossover #  File position: /EMOC/src/operator/order_crossover.h and /EMOC/src/operator/order_crossover.cpp\n .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }   void OrderCrossover(Individual *parent1, Individual *parent2, Individual *offspring1, Individual *offspring2)   Do the order crossover on parent1 and parent2, the results are stored in offspring1 and offspring2. Note this crossover is for permutation encoding problems.\n Parameter:  parent1: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the first parent individual to do order crossover. parent2: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the second parent individual to do order crossover. offspring1: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the first offspring individual of order crossover results. The memory of the offspring need to be allocated outside the function. offspring2: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the second offspring individual of order crossover results. The memory of the offspring need to be allocated outside the function.   Returns:  void     "},{"id":26,"href":"/EMOCDoc/docs/core_class/emoc_manager/","title":"EMOCManager","section":"Core Class","content":"EMOCManager Class #  File position: /EMOC/src/core/emoc_manager.h and /EMOC/src/core/emoc_manager.cpp\nclass EMOCManager()  EMOCManager is the manager class of EMOC which controls the command mode and GUI mode.\n .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }    Parameter:   void   Member variables:  (private) is_plot_: bool\u0026nbsp \u0026nbsp Whether to activate plot function.  (private) is_gui_: bool\u0026nbsp \u0026nbsp Whether to enable gui mode. (private) is_experiment_: bool\u0026nbsp \u0026nbsp Whether in experiment module of gui mode. (private) is_test_pause_: bool\u0026nbsp \u0026nbsp Whether current run is paused in test module of gui mode. (private) is_test_finish_: bool\u0026nbsp \u0026nbsp Whether current run is finished in test module of gui mode.  (private) is_experiment_pause_: bool\u0026nbsp \u0026nbsp Whether current run is finished in experiment module of gui mode.  (private) is_experiment_finish_: bool\u0026nbsp \u0026nbsp Whether current run is finished in experiment module of gui mode.  (private) g_GlobalSettingsArray: std::vector\u0026ltGlobal*\u0026gt\u0026nbsp \u0026nbsp An array of pointer to Global, it is reserved for different threads. The size of the vector is MAX_THREAD_NUM which is a macro definition in EMOC. By default the value is 128.     Note: Most of the private member variables can be set or got by the corresponding Get and Set functions. For more details, please check the source code.\n Public Methods:\n static EMOCManager* Instance() void Run() void ExperimentModuleRun(std::vector experiment_tasks, int thread_num)  static EMOCManager* Instance()   Get the pointer to current EMOCManager object.\nIn EMOC, the EMOCManager class utilize the singleton design mode. So the object can be retrieved anywhere by EMOCManager::Instance() directly.\n Parameter:  void   Returns:  s_Instance: EMOCManager*\u0026nbsp \u0026nbsp Pointer to the current EMOCManager object iteself.      void Run()   The run function for command line mode in EMOC.\n  Parameter:   void   Returns:  void     void ExperimentModuleRun(std::vector\u0026lt;EMOCParameters\u0026gt; experiment_tasks, int thread_num)   The run function for experiment module of gui mode in EMOC.\n Parameter:  experiment_tasks: std::vector\u0026ltEMOCParameters\u0026gt, default=None\u0026nbsp \u0026nbsp All EMOC tasks need to be completed which are configured in experiment module of gui mode. thread_num: int, default=None\u0026nbsp \u0026nbsp The number of enabled thread.   Returns:  void     "},{"id":27,"href":"/EMOCDoc/docs/utility_function/miscellaneous/","title":"Miscellaneous","section":"Utility Function","content":"Ideal Point and Nadir Point Update #   .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }  File position: /EMOC/src/core/utility.h and /EMOC/src/core/utility.cpp\n void UpdateIdealpoint(Individual *ind, double *ideal_point, int obj_num) void UpdateNadirpoint(Individual *ind, double *nadir_point, int obj_num)  void UpdateIdealpoint(Individual *ind, double *ideal_point, int obj_num)   Update the ideal point ideal_point with given individual ind.\n Parameter:  ind: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the given individual. ideal_point: double*, default=None\u0026nbsp \u0026nbsp The pointer to the ideal point which will be updated. It's a 1D array of double. obj_num: int, default=None\u0026nbsp \u0026nbsp The number of objectives.   Returns:  void     void UpdateNadirpoint(Individual *ind, double *nadir_point, int obj_num)   Update the ideal point nadir_point with given individual ind.\n Parameter:  ind: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the given individual. ideal_point: double*, default=None\u0026nbsp \u0026nbsp The pointer to the nadir point which will be updated. It's a 1D array of double. obj_num: int, default=None\u0026nbsp \u0026nbsp The number of objectives.   Returns:  void     Statistic Test #  File position: /EMOC/src/core/utility.h and /EMOC/src/core/utility.cpp\n int RankSumTest(const std::vector\u0026lt;double\u0026gt;\u0026amp; array1, const std::vector\u0026lt;double\u0026gt;\u0026amp; array2) int SignRankTest(const std::vector\u0026lt;double\u0026gt;\u0026amp; array1, const std::vector\u0026lt;double\u0026gt;\u0026amp; array2)  int RankSumTest(const std::vector\u0026lt;double\u0026gt;\u0026amp; array1, const std::vector\u0026lt;double\u0026gt;\u0026amp; array2)   Do the ranksum test between the two given arrays.\n Parameter:  array1: std::vector\u0026ltdouble\u0026gt, default=None\u0026nbsp \u0026nbsp The first array which will attend ranksum test. array2: std::vector\u0026ltdouble\u0026gt, default=None\u0026nbsp \u0026nbsp The second array which will attend ranksum test.   Returns:  res: int\u0026nbsp \u0026nbsp The result of ranksum test. 0 means no significant difference and 1 means has significant difference with 5% significance level.     int SignRankTest(const std::vector\u0026lt;double\u0026gt;\u0026amp; array1, const std::vector\u0026lt;double\u0026gt;\u0026amp; array2)   Do the sign rank test between the two given arrays.\n Parameter:  array1: std::vector\u0026ltdouble\u0026gt, default=None\u0026nbsp \u0026nbsp The first array which will attend sign rank test. array2: std::vector\u0026ltdouble\u0026gt, default=None\u0026nbsp \u0026nbsp The second array which will attend sign rank test.   Returns:  res: int\u0026nbsp \u0026nbsp The result of sign rank test. 0 means no significant difference and 1 means has significant difference with 5% significance level.     "},{"id":28,"href":"/EMOCDoc/docs/operator/polynomial_mutation/","title":"Polynomial Mutation","section":"Operator","content":"Polynomial Mutation #  File position: /EMOC/src/operator/polynomial_mutation.h and /EMOC/src/operator/polynomial_mutation.cpp\n .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }   void PolynomialMutation(Individual *ind, std::vector\u0026lt;double\u0026gt;\u0026amp; lower_bound, std::vector\u0026lt;double\u0026gt;\u0026amp; upper_bound, MutationParameter\u0026amp; mutation_para)   Do the polynomial mutation on ind. The mutation results are stored in itself.\n Parameter:  ind: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the individual which will do the polynomial mutation. lower_bound: std::vector\u0026ltdouble\u0026gt, default=None\u0026nbsp \u0026nbsp The lower boundary of decision variables. upper_bound: std::vector\u0026ltdouble\u0026gt, default=None\u0026nbsp \u0026nbsp The upper boundary of decision variables. mutation_para: MutationParameter, default=None\u0026nbsp \u0026nbsp The parameter of this mutation. The type MutationParameter is just a simple structure which has three member variables (i.e., the mutation probability, the distribution index1 and the distribution index2).   Returns:  void     "},{"id":29,"href":"/EMOCDoc/docs/indicator/spacing/","title":"Spacing","section":"Indicator","content":"Spacing #  File position: /EMOC/src/metric/spacing.h and /EMOC/src/metric/spacing.cpp\n .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }   double CalculateSpacing(Individual **pop, int pop_num, int obj_num)   Calculate the spacing value of current population pop.\n Parameter:  pop: Individual**, default=None\u0026nbsp \u0026nbsp The population which need to be initialized. It's an array of Individual* where each Individual* is a pointer to a individual in the population. pop_num: int, default=None\u0026nbsp \u0026nbsp The size of the given population. obj_num: int, default=None\u0026nbsp \u0026nbsp The number of objectives.   Returns:  spacing_value: double\u0026nbsp \u0026nbsp Spacing value of current population pop.     "},{"id":30,"href":"/EMOCDoc/docs/operator/bit_mutation/","title":"Bit Flip Mutation","section":"Operator","content":"Bit Flip Mutation #  File position: /EMOC/src/operator/bit_mutation.h and /EMOC/src/operator/bit_mutation.cpp\n .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }   void BitFlipMutation(Individual *ind, MutationParameter \u0026amp;mutation_para)   Do the bit flip mutation on ind. The mutation results are stored in itself. Note this mutation is for binary encoding problems.\n Parameter:  ind: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the individual which will do the bit flip mutation. mutation_para: MutationParameter, default=None\u0026nbsp \u0026nbsp The parameter of this mutation. The type MutationParameter is just a simple structure which has three member variables (i.e., the mutation probability, the distribution index1 and the distribution index2).   Returns:  void     "},{"id":31,"href":"/EMOCDoc/docs/python_dll/","title":"Python DLL","section":"Docs","content":"Python Dynamic Link Library #   .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }  In Quick Start section, we give a brief introduction on how to use EMOC in python language. Basically speaking, several fundamental classes are exported into python. So the users can utilize these classes to define their own problem and solve it with available algorithms in EMOC.\nIn this section, we will give the detailed definition of these exported classes to help users understand the python dynamic link library of EMOC.\nExported Classes #  Problem #  This class is basically the same as original class in C++ except some member variable names.\nclass Problem(int dec_num, int obj_num)  The parent class of all test problems in EMOC. The custom problem in python need to inherit form this class.\n  Parameter:   dec_num: int, default=None\u0026nbsp \u0026nbsp The number of decision variables setting for the problem. obj_num: int, default=None\u0026nbsp \u0026nbsp The number of objective functions setting for the problem.   Member variables:  (public) dec_num: int\u0026nbsp \u0026nbsp The number of decision variables set by users. It is equal to the given dec_num.  (public) obj_num: int\u0026nbsp \u0026nbsp The number of objective functions set by users. It is equal to the given obj_num. (public) lower_bound: std::vector\u0026ltdouble\u0026gt\u0026nbsp \u0026nbsp The lower bound of each decision variable. The size of this std::vector is dec_num. (public) upper_bound: std::vector\u0026ltdouble\u0026gt\u0026nbsp \u0026nbsp The upper bound of each decision variable. The size of this std::vector is dec_num.      Public Member Functions:\n void CalObj(Individual* ind)  void CalObj(Individual* ind)   Calculate the objective function values.\nThis function is a pure virtual function which must be implemented in custom problem in python.\n Parameter:  ind: Individual*, default=None\u0026nbsp \u0026nbsp Pointer to the individual which need to calculate the objectives.   Returns:  void      Individual #  This class is basically the same as original class in C++ except some member variable names.\nclass Individual(int dec_num, int obj_num)  The class for each individual in the population.\n  Parameter:   dec_num: int, default=None\u0026nbsp \u0026nbsp The number of decision variables. obj_num: int, default=None\u0026nbsp \u0026nbsp The number of objectives.   Member variables:  (public) dec: std::vector\u0026ltdouble\u0026gt\u0026nbsp \u0026nbsp Decision variables of this individual. The size of this std::vector is dec_num.  (public) obj: std::vector\u0026ltdouble\u0026gt\u0026nbsp \u0026nbsp Objectives of this individual. The size of this std::vector is obj_num.      EMOCManager #  class EMOCManager()  EMOCManager is the manager class of EMOC which controls the execution of EMOC. Most original member variables in C++ definition are omitted. Because they are not needed in python.\n  Parameter:   void   Member variables:  void      Public Methods:\n void Run() void SetTaskParameters(const EMOCParameters\u0026amp; para) EMOCGeneralResult GetPythonResult()  void Run()   Start this optimization with current parameters.\n  Parameter:   void   Returns:  void     void SetTaskParameters(const EMOCParameters\u0026amp; para)   Set the parameters of this execution\n  Parameter:   para: const EMOCParameters\u0026, default=None\u0026nbsp \u0026nbsp Parameters of this run.   Returns:  void     EMOCGeneralResult GetPythonResult()   Get the optimization results of this run.\n  Parameter:   void   Returns:  result: EMOCGeneralResult\u0026nbsp \u0026nbsp Optimization results of this run.      EMOCParameters #  class EMOCParameters()  EMOCParameters is a simple structure consists of basic parameter settings variables and two public interface for configuring custom problem and initial population\n  Parameter:   void   Member variables:  (public) algorithm_name: string\u0026nbsp \u0026nbsp Algorithm name.  (public) problem_name: string\u0026nbsp \u0026nbsp Problem name.  (public) population_num: int\u0026nbsp \u0026nbsp The size of population.  (public) decision_num: int\u0026nbsp \u0026nbsp The number of decision variables.  (public) objective_num: int\u0026nbsp \u0026nbsp The number of objectives.  (public) max_evaluation: int\u0026nbsp \u0026nbsp The max evaluation times of this optimization.  (public) output_interval: int\u0026nbsp \u0026nbsp Save interval in generation.      Public Methods:\n void SetProblem(Problem* problem) void SetInitialPop(std::vector\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt; initial_pop)  void SetProblem(Problem* problem)   Set the custom problem.\n  Parameter:   problem: Problem*, default=None\u0026nbsp \u0026nbsp Pointer to the custom problem. This can be an problem object in python.   Returns:  void     void SetInitialPop(std::vector\u0026lt;std::vector\u0026lt;double\u0026gt;\u0026gt; initial_pop)   Set the custom initial population.\n  Parameter:   initial_pop: std::vector\u0026ltstd::vector\u0026ltdouble\u0026gt\u0026gt, default=None\u0026nbsp \u0026nbsp The custom initial population. It's basically a 2D array of double. Each row is the decision variables of an individual.   Returns:  void      EMOCGeneralResult #  class EMOCGeneralResult()  The class for the optimization results which can get by EMOCManager::GetResult().\n  Parameter:   void   Member variables:  (public) igd: double\u0026nbsp \u0026nbsp IGD value of this optimization. This is only valid in multi-objective optimization problem.  (public) gd: double\u0026nbsp \u0026nbsp GD value of this optimization. This is only valid in multi-objective optimization problem. (public) hv: double\u0026nbsp \u0026nbsp HV value of this optimization. This is only valid in multi-objective optimization problem. (public) spacing: double\u0026nbsp \u0026nbsp Spacing value of this optimization. This is only valid in multi-objective optimization problem. (public) igdplus: double\u0026nbsp \u0026nbsp IGD Plus value of this optimization. This is only valid in multi-objective optimization problem. (public) gdplus: double\u0026nbsp \u0026nbsp GD Plus value of this optimization. This is only valid in multi-objective optimization problem. (public) best_value: double\u0026nbsp \u0026nbsp Best found value. This is only valid in single-objective optimization problem.  (public) runtime: double\u0026nbsp \u0026nbsp The run time of this run.  (public) pop_num: int\u0026nbsp \u0026nbsp The size of the final population.  (public) pop_decs: 2D list\u0026nbsp \u0026nbsp Decision variables of final population.  (public) pop_objs: 2D list\u0026nbsp \u0026nbsp Objectives of final population.    "},{"id":32,"href":"/EMOCDoc/docs/operator/swap_mutation/","title":"Swap Mutation","section":"Operator","content":"Swap Mutation #  File position: /EMOC/src/operator/swap_mutation.h and /EMOC/src/operator/swap_mutation.cpp\n .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; }   void SwapMutation(Individual *ind, MutationParameter \u0026amp;mutation_para)   Do the swap mutation on ind. The mutation results are stored in itself. Note this mutation is for permutation encoding problems.\n Parameter:  ind: Individual*, default=None\u0026nbsp \u0026nbsp The pointer to the individual which will do the swap mutation. mutation_para: MutationParameter, default=None\u0026nbsp \u0026nbsp The parameter of this mutation. The type MutationParameter is just a simple structure which has three member variables (i.e., the mutation probability, the distribution index1 and the distribution index2).   Returns:  void     "}]