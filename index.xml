<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>EMOC</title><link>https://sunxlei.github.io/EMOCDoc/</link><description>Recent content on EMOC</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://sunxlei.github.io/EMOCDoc/index.xml" rel="self" type="application/rss+xml"/><item><title>Architecture of EMOC</title><link>https://sunxlei.github.io/EMOCDoc/docs/core_class/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/core_class/overview/</guid><description>Architecture of EMOC # Before we dive into the details and functions of some core classes, let&amp;rsquo;s take a look at the architecture of EMOC.
File Structure # After going into the source code directory &amp;rsquo;/EMOC/src&amp;rsquo;, users can see a lot of .h and .cpp files organized in a structure shown below.
There are one &amp;lsquo;main.cpp&amp;rsquo; file and six folders in the &amp;rsquo;/src&amp;rsquo; directory of EMOC. It is very easy to find the implementation details of specified algorithms, problems, operators and metrics in each folders.</description></item><item><title>Generational Distance</title><link>https://sunxlei.github.io/EMOCDoc/docs/indicator/gd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/indicator/gd/</guid><description>Generational Distance # File position: /EMOC/src/metric/gd.h and /EMOC/src/metric/gd.cpp
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } double CalculateGD(Individual** pop, int pop_num, int obj_num, double** pf_data, int pf_size) Calculate the generational distance value of current population pop based on the pareto front data pf_data.
Parameter: pop: Individual**, default=None&amp;nbsp &amp;nbsp The population which need to be initialized. It's an array of Individual* where each Individual* is a pointer to a individual in the population.</description></item><item><title>Graphic User Interface Mode</title><link>https://sunxlei.github.io/EMOCDoc/docs/quickstart/user_interface_mode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/quickstart/user_interface_mode/</guid><description>Graphic User Interface Mode # EMOC is implemented with a user-friendly graphic user interface (GUI) which can help users get started quickly. We recommend using EMOC in GUI mode for general cases.
Run EMOC with GUI # When EMOC has been built successfully, go to the directory of executable file and open the terminal. Enable the user interface mode with the following command:
./EMOC -g For windows, change the &amp;rsquo;.</description></item><item><title>Non-dominated Sorting</title><link>https://sunxlei.github.io/EMOCDoc/docs/utility_function/ndsort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/utility_function/ndsort/</guid><description>Non-dominated Sorting # File position: /EMOC/src/core/nd_sort.h and /EMOC/src/core/nd_sort.cpp
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } void NonDominatedSort(Individual **pop, int pop_num, int obj_num, bool is_consider_cons = false) Do the non-dominated sorting on current population pop. The results are stored in the rank_ variable of each individual in the population.
Parameter: pop: Individual**, default=None&amp;nbsp &amp;nbsp The population which need to be initialized. It's an array of Individual* where each Individual* is a pointer to a individual in the population.</description></item><item><title>Problem</title><link>https://sunxlei.github.io/EMOCDoc/docs/extend_emoc/problem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/extend_emoc/problem/</guid><description>Add New Problems in EMOC # Due to the simple structure of EMOC, it is straightforward to add a new problem in EMOC. This needs three steps as below. We will take the test problem ZDT1 as an example.
Create the Declaration # First, we need to create a header file to make a declaration of ZDT1. Although there is no strict position request. We recommend to go to the directory &amp;rsquo;/src/problem/&amp;rsquo;, make a new directory &amp;rsquo;/zdt&amp;rsquo; and create a header file &amp;lsquo;zdt.</description></item><item><title>Tournament Selection</title><link>https://sunxlei.github.io/EMOCDoc/docs/operator/tournament_selection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/operator/tournament_selection/</guid><description>Tournament Selection # File position: /EMOC/src/operator/tournament_selection.h and /EMOC/src/operator/tournament_selection.cpp
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } There are three tournament selection variants in EMOCï¼š
Individual* TournamentByRank(Individual* ind1, Individual* ind2)
Individual* TournamentByFitness(Individual* ind1, Individual* ind2, int greater_is_better = 0)
Individual* TournamentByCustom(Individual* ind1, double ind1_prop, Individual* ind2, double ind2_prop, int greater_is_better = 0)
Individual* TournamentByRank(Individual* ind1, Individual* ind2) Use the non-dominated sorting results (i.</description></item><item><title>Algorithm</title><link>https://sunxlei.github.io/EMOCDoc/docs/extend_emoc/algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/extend_emoc/algorithm/</guid><description>Add New Algorithms in EMOC # Adding a new algorithm is very similar to adding a new problem. We will take NSGA2 as an example (for simplicity, some details are omitted, users can check the complete source code themselves).
Create the Declaration # First, let&amp;rsquo;s go to the directory &amp;rsquo;/src/algorithm/&amp;rsquo;, make a new directory &amp;rsquo;/nsga2&amp;rsquo; and create a header file &amp;rsquo;nsga2.h&amp;rsquo; in it. We make the declaration about class NSGA2 which inherits from class Algorithm in &amp;rsquo;nsga2.</description></item><item><title>Command Line Mode</title><link>https://sunxlei.github.io/EMOCDoc/docs/quickstart/command_line_mode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/quickstart/command_line_mode/</guid><description>Command Line Mode # Except using EMOC in the GUI mode, we also provide command line (CMD) mode for these users who don&amp;rsquo;t have a display screen for some reasons(like on a remote server).
A Simple Case # Go to the directory of executable file and open the terminal. Users can run EMOC with default parameters by just:
./EMOC For windows, change the &amp;rsquo;./EMOC&amp;rsquo; to &amp;lsquo;EMOC.exe&amp;rsquo;. Some settings and results information will be printed in the terminal:</description></item><item><title>Generational Distance Plus</title><link>https://sunxlei.github.io/EMOCDoc/docs/indicator/gd_plus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/indicator/gd_plus/</guid><description>Generational Distance Plus # File position: /EMOC/src/metric/gd_plus.h and /EMOC/src/metric/gd_plus.cpp
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } double CalculateGDPlus(Individual** pop, int pop_num, int obj_num, double** pf_data, int pf_size) Calculate the generational distance plus value of current population pop based on the pareto front data pf_data.
Parameter: pop: Individual**, default=None&amp;nbsp &amp;nbsp The population which need to be initialized. It's an array of Individual* where each Individual* is a pointer to a individual in the population.</description></item><item><title>Individual</title><link>https://sunxlei.github.io/EMOCDoc/docs/core_class/individual/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/core_class/individual/</guid><description>Individual Class # File position: /EMOC/src/core/individual.h and /EMOC/src/core/individual.cpp
class Individual(int dec_num, int obj_num) The class for each individual in the population.
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } Parameter: dec_num: int, default=None&amp;nbsp &amp;nbsp The number of decision variables. obj_num: int, default=None&amp;nbsp &amp;nbsp The number of objectives. Member variables: (public) dec_: std::vector&amp;ltdouble&amp;gt&amp;nbsp &amp;nbsp Decision variables of this individual. The size of this std::vector is dec_num.</description></item><item><title>Simulated Binary Crossover</title><link>https://sunxlei.github.io/EMOCDoc/docs/operator/sbx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/operator/sbx/</guid><description>Simulated Binary Crossover # File position: /EMOC/src/operator/sbx.h and /EMOC/src/operator/sbx.cpp
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } void SBX(Individual* parent1, Individual* parent2, Individual* offspring1, Individual* offspring2, std::vector&amp;lt;double&amp;gt;&amp;amp; lower_bound, std::vector&amp;lt;double&amp;gt;&amp;amp; upper_bound, CrossoverParameter&amp;amp; cross_para) Do the simulated binary crossover based on parent1 and parent2, the results are stored in offspring1 and offspring2.
Parameter: parent1: Individual*, default=None&amp;nbsp &amp;nbsp The pointer to the first parent individual to do simulated binary crossover.</description></item><item><title>Uniform Weight Vector Generation</title><link>https://sunxlei.github.io/EMOCDoc/docs/utility_function/uniform_weight_vector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/utility_function/uniform_weight_vector/</guid><description>Uniform Weight Vector Generation # File position: /EMOC/src/core/uniform_point.h and /EMOC/src/core/uniform_point.cpp
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } double** UniformPoint(int num, int* weight_num, int obj_num) Generate uniform weight vectors.
Parameter: num: int, default=None&amp;nbsp &amp;nbsp Number of uniform weight vectors want to generate. weight_num: int*, default=None&amp;nbsp &amp;nbsp The real number of generated weight vectors. obj_num: int, default=None&amp;nbsp &amp;nbsp The dimension of generated weight vectors. Returns: lambda: double**&amp;nbsp &amp;nbsp Generated uniform weight vectors.</description></item><item><title>Aggregation Functions</title><link>https://sunxlei.github.io/EMOCDoc/docs/utility_function/aggregation_functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/utility_function/aggregation_functions/</guid><description>Aggregation Functions # File position: /EMOC/src/core/utility.h and /EMOC/src/core/utility.cpp
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } There are several aggregation functions for decomposition:
double CalWeightedSum(Individual *ind, double *weight_vector, double *ideal_point, int obj_num)
double CalInverseChebycheff(Individual *ind, double *weight_vector, double *ideal_point, int obj_num)
double CalPBI(Individual *ind, double *weight_vector, double *ideal_point, int obj_num, double theta)
double CalWeightedSum(Individual *ind, double *weight_vector, double *ideal_point, int obj_num) Use weighted sum method to decompose the individual ind based on weight vector weight_vector.</description></item><item><title>Differential Evolution</title><link>https://sunxlei.github.io/EMOCDoc/docs/operator/de/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/operator/de/</guid><description>Differential Evolution # File position: /EMOC/src/operator/de.h and /EMOC/src/operator/de.cpp
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } void DE(Individual *parent1, Individual *parent2, Individual *parent3, Individual *offspring, std::vector&amp;lt;double&amp;gt;&amp;amp; lower_bound, std::vector&amp;lt;double&amp;gt;&amp;amp; upper_bound, CrossoverParameter&amp;amp; cross_para) Do the differential evolution on parent1 , parent2 and parent3, the results are stored in offspring.
Parameter: parent1: Individual*, default=None&amp;nbsp &amp;nbsp The pointer to the first parent individual to do differential evolution. parent2: Individual*, default=None&amp;nbsp &amp;nbsp The pointer to the second parent individual to do differential evolution.</description></item><item><title>Inverted Generational Distance</title><link>https://sunxlei.github.io/EMOCDoc/docs/indicator/igd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/indicator/igd/</guid><description>Inverted Generational Distance # File position: /EMOC/src/metric/igd.h and /EMOC/src/metric/igd.cpp
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } double CalculateIGD(Individual** pop, int pop_num, int obj_num, double** pf_data, int pf_size) Calculate the inverted generational distance value of current population pop based on the pareto front data pf_data.
Parameter: pop: Individual**, default=None&amp;nbsp &amp;nbsp The population which need to be initialized. It's an array of Individual* where each Individual* is a pointer to a individual in the population.</description></item><item><title>Problem</title><link>https://sunxlei.github.io/EMOCDoc/docs/core_class/problem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/core_class/problem/</guid><description>Problem Class # File position: /EMOC/src/problem/problem.h and /EMOC/src/problem/problem.cpp
class Problem(int dec_num, int obj_num) The parent class of all test problems in EMOC.
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } Parameter: dec_num: int, default=None&amp;nbsp &amp;nbsp The number of decision variables setting for the problem. obj_num: int, default=None&amp;nbsp &amp;nbsp The number of objective functions setting for the problem. Member variables: (public) dec_num_: int&amp;nbsp &amp;nbsp The number of decision variables set by users.</description></item><item><title>Use EMOC in Python</title><link>https://sunxlei.github.io/EMOCDoc/docs/quickstart/use_emoc_in_python/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/quickstart/use_emoc_in_python/</guid><description>Use EMOC in Python # To increase the flexibility of EMOC, we also provide a method to compile the source code to a python dynamic link library (DLL). So that EMOC can be used in python language too.
Build # EMOC project provides script files on different platforms for the ease of building.
Open your platform&amp;rsquo;s script file with a text editor and find the row begin with cmake -DBUILD_PYTHON_DLL=OFF.</description></item><item><title>Algorithm</title><link>https://sunxlei.github.io/EMOCDoc/docs/core_class/algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/core_class/algorithm/</guid><description>Algorithm Class # File position: /EMOC/src/algorithm/algorithm.h and /EMOC/src/algorithm/algorithm.cpp
class Algorithm(int thread_id) The parent class of all algorithms in EMOC. It provides some useful functions for subclasses such as population evaluation and copy.
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } Parameter: thread_id: int, default=0&amp;nbsp &amp;nbsp Index of current thread index. EMOC reserved an array of Global objects. Each object is owned by an unique thread.</description></item><item><title>Inverted Generational Distance Plus</title><link>https://sunxlei.github.io/EMOCDoc/docs/indicator/igd_plus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/indicator/igd_plus/</guid><description>Inverted Generational Distance Plus # File position: /EMOC/src/metric/igd_plus.h and /EMOC/src/metric/igd_plus.cpp
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } double CalculateIGDPlus(Individual** pop, int pop_num, int obj_num, double** pf_data, int pf_size) Calculate the inverted generational distance plus value of current population pop based on the pareto front data pf_data.
Parameter: pop: Individual**, default=None&amp;nbsp &amp;nbsp The population which need to be initialized. It's an array of Individual* where each Individual* is a pointer to a individual in the population.</description></item><item><title>Sampling Functions</title><link>https://sunxlei.github.io/EMOCDoc/docs/utility_function/sampling_functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/utility_function/sampling_functions/</guid><description>Sampling Functions # .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } Random Number Generation # File position: /EMOC/vendor/random.h and /EMOC/vendor/random.cpp
Random number generation is a basic function for evolutionary algorithm, EMOC provides several random number related functions as below:
double randomperc() int rnd(int low, int high) double rndreal(double low, double high) double randomperc() Fetch a single random number between 0.0 and 1.0.
Parameter: void Returns: rand: double&amp;nbsp &amp;nbsp A random number between 0.</description></item><item><title>Uniform Crossover</title><link>https://sunxlei.github.io/EMOCDoc/docs/operator/uniform_crossover/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/operator/uniform_crossover/</guid><description>Uniform Crossover # File position: /EMOC/src/operator/uniform_crossover.h and /EMOC/src/operator/uniform_crossover.cpp
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } void UniformCrossover(Individual *parent1, Individual *parent2, Individual *offspring1, Individual *offspring2) Do the uniform crossover on parent1 and parent2, the results are stored in offspring1 and offspring2. Note this crossover is for binary encoding problems.
Parameter: parent1: Individual*, default=None&amp;nbsp &amp;nbsp The pointer to the first parent individual to do uniform crossover.</description></item><item><title>Global</title><link>https://sunxlei.github.io/EMOCDoc/docs/core_class/global/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/core_class/global/</guid><description>Global Class # File position: /EMOC/src/core/global.h and /EMOC/src/core/global.cpp
class Global(const char* algorithm_name, const char* problem_name, int population_num, int dec_num, int obj_num, int max_evaluation, int thread_id, int output_interval, int run_id = 0) Global class represents an execution entity of EMOC which basically is a specified algorithm optimized a certain problem with pre-defined parameters. It holds all the relevant datas such as the pointer to algorithm, the pointer to problem, optimization settings and the population.</description></item><item><title>Hypervolume</title><link>https://sunxlei.github.io/EMOCDoc/docs/indicator/hv/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/indicator/hv/</guid><description>Hypervolume # File position: /EMOC/src/metric/hv.h and /EMOC/src/metric/hv.cpp
Due to the complexity of calculating hypervolume, we use a class to encapsulate the details into a class HVCalculator. The most important public interface is the following:
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } double HVCalculator::Calculate(Individual** pop, int pop_num, int obj_num, double** pf_data, int pf_size) Calculate the hypervolume value of current population pop based on the pareto front data pf_data.</description></item><item><title>Math Related Functions</title><link>https://sunxlei.github.io/EMOCDoc/docs/utility_function/math_related_functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/utility_function/math_related_functions/</guid><description>Math Related Functions # File position: /EMOC/src/core/utility.h and /EMOC/src/core/utility.cpp
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } In EMOC, some mathematic operations are also provided for convenience:
int Combination(int n, int k)
double CalculateCos(double *a, double *b, int dimension)
double CalculateSin(double *a, double *b, int dimension)
double CalculateNorm(double *vector, int dimension)
double CalculateDotProduct(double *vector1, double *vector2, int dimension)</description></item><item><title>Order Crossover</title><link>https://sunxlei.github.io/EMOCDoc/docs/operator/order_crossover/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/operator/order_crossover/</guid><description>Order Crossover # File position: /EMOC/src/operator/order_crossover.h and /EMOC/src/operator/order_crossover.cpp
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } void OrderCrossover(Individual *parent1, Individual *parent2, Individual *offspring1, Individual *offspring2) Do the order crossover on parent1 and parent2, the results are stored in offspring1 and offspring2. Note this crossover is for permutation encoding problems.
Parameter: parent1: Individual*, default=None&amp;nbsp &amp;nbsp The pointer to the first parent individual to do order crossover.</description></item><item><title>EMOCManager</title><link>https://sunxlei.github.io/EMOCDoc/docs/core_class/emoc_manager/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/core_class/emoc_manager/</guid><description>EMOCManager Class # File position: /EMOC/src/core/emoc_manager.h and /EMOC/src/core/emoc_manager.cpp
class EMOCManager() EMOCManager is the manager class of EMOC which controls the command mode and GUI mode.
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } Parameter: void Member variables: (private) is_plot_: bool&amp;nbsp &amp;nbsp Whether to activate plot function. (private) is_gui_: bool&amp;nbsp &amp;nbsp Whether to enable gui mode. (private) is_experiment_: bool&amp;nbsp &amp;nbsp Whether in experiment module of gui mode.</description></item><item><title>Miscellaneous</title><link>https://sunxlei.github.io/EMOCDoc/docs/utility_function/miscellaneous/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/utility_function/miscellaneous/</guid><description>Ideal Point and Nadir Point Update # .emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } File position: /EMOC/src/core/utility.h and /EMOC/src/core/utility.cpp
void UpdateIdealpoint(Individual *ind, double *ideal_point, int obj_num) void UpdateNadirpoint(Individual *ind, double *nadir_point, int obj_num) void UpdateIdealpoint(Individual *ind, double *ideal_point, int obj_num) Update the ideal point ideal_point with given individual ind.
Parameter: ind: Individual*, default=None&amp;nbsp &amp;nbsp The pointer to the given individual. ideal_point: double*, default=None&amp;nbsp &amp;nbsp The pointer to the ideal point which will be updated.</description></item><item><title>Polynomial Mutation</title><link>https://sunxlei.github.io/EMOCDoc/docs/operator/polynomial_mutation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/operator/polynomial_mutation/</guid><description>Polynomial Mutation # File position: /EMOC/src/operator/polynomial_mutation.h and /EMOC/src/operator/polynomial_mutation.cpp
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } void PolynomialMutation(Individual *ind, std::vector&amp;lt;double&amp;gt;&amp;amp; lower_bound, std::vector&amp;lt;double&amp;gt;&amp;amp; upper_bound, MutationParameter&amp;amp; mutation_para) Do the polynomial mutation on ind. The mutation results are stored in itself.
Parameter: ind: Individual*, default=None&amp;nbsp &amp;nbsp The pointer to the individual which will do the polynomial mutation. lower_bound: std::vector&amp;ltdouble&amp;gt, default=None&amp;nbsp &amp;nbsp The lower boundary of decision variables.</description></item><item><title>Spacing</title><link>https://sunxlei.github.io/EMOCDoc/docs/indicator/spacing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/indicator/spacing/</guid><description>Spacing # File position: /EMOC/src/metric/spacing.h and /EMOC/src/metric/spacing.cpp
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } double CalculateSpacing(Individual **pop, int pop_num, int obj_num) Calculate the spacing value of current population pop.
Parameter: pop: Individual**, default=None&amp;nbsp &amp;nbsp The population which need to be initialized. It's an array of Individual* where each Individual* is a pointer to a individual in the population. pop_num: int, default=None&amp;nbsp &amp;nbsp The size of the given population.</description></item><item><title>Bit Flip Mutation</title><link>https://sunxlei.github.io/EMOCDoc/docs/operator/bit_mutation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/operator/bit_mutation/</guid><description>Bit Flip Mutation # File position: /EMOC/src/operator/bit_mutation.h and /EMOC/src/operator/bit_mutation.cpp
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } void BitFlipMutation(Individual *ind, MutationParameter &amp;amp;mutation_para) Do the bit flip mutation on ind. The mutation results are stored in itself. Note this mutation is for binary encoding problems.
Parameter: ind: Individual*, default=None&amp;nbsp &amp;nbsp The pointer to the individual which will do the bit flip mutation. mutation_para: MutationParameter, default=None&amp;nbsp &amp;nbsp The parameter of this mutation.</description></item><item><title>Swap Mutation</title><link>https://sunxlei.github.io/EMOCDoc/docs/operator/swap_mutation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sunxlei.github.io/EMOCDoc/docs/operator/swap_mutation/</guid><description>Swap Mutation # File position: /EMOC/src/operator/swap_mutation.h and /EMOC/src/operator/swap_mutation.cpp
.emoc_doc_table_title{ background-color:#F0F7FA; } .emoc_doc_table_content{ background-color:#FFFFFF; width:100%; } void SwapMutation(Individual *ind, MutationParameter &amp;amp;mutation_para) Do the swap mutation on ind. The mutation results are stored in itself. Note this mutation is for permutation encoding problems.
Parameter: ind: Individual*, default=None&amp;nbsp &amp;nbsp The pointer to the individual which will do the swap mutation. mutation_para: MutationParameter, default=None&amp;nbsp &amp;nbsp The parameter of this mutation.</description></item></channel></rss>